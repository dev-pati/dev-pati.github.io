/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */let Mt,Nt;function wt(){return{geminiUrl:Mt,vertexUrl:Nt}}function Dt(n,e,t,o){var r,l;if(!(n!=null&&n.baseUrl)){const a=wt();return e?(r=a.vertexUrl)!==null&&r!==void 0?r:t:(l=a.geminiUrl)!==null&&l!==void 0?l:o}return n.baseUrl}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class B{}function y(n,e){const t=/\{([^}]+)\}/g;return n.replace(t,(o,r)=>{if(Object.prototype.hasOwnProperty.call(e,r)){const l=e[r];return l!=null?String(l):""}else throw new Error(`Key '${r}' not found in valueMap.`)})}function s(n,e,t){for(let l=0;l<e.length-1;l++){const a=e[l];if(a.endsWith("[]")){const u=a.slice(0,-2);if(!(u in n))if(Array.isArray(t))n[u]=Array.from({length:t.length},()=>({}));else throw new Error(`Value must be a list given an array path ${a}`);if(Array.isArray(n[u])){const c=n[u];if(Array.isArray(t))for(let d=0;d<c.length;d++){const f=c[d];s(f,e.slice(l+1),t[d])}else for(const d of c)s(d,e.slice(l+1),t)}return}else if(a.endsWith("[0]")){const u=a.slice(0,-3);u in n||(n[u]=[{}]);const c=n[u];s(c[0],e.slice(l+1),t);return}(!n[a]||typeof n[a]!="object")&&(n[a]={}),n=n[a]}const o=e[e.length-1],r=n[o];if(r!==void 0){if(!t||typeof t=="object"&&Object.keys(t).length===0||t===r)return;if(typeof r=="object"&&typeof t=="object"&&r!==null&&t!==null)Object.assign(r,t);else throw new Error(`Cannot set value for an existing key. Key: ${o}`)}else o==="_self"&&typeof t=="object"&&t!==null&&!Array.isArray(t)?Object.assign(n,t):n[o]=t}function i(n,e,t=void 0){try{if(e.length===1&&e[0]==="_self")return n;for(let o=0;o<e.length;o++){if(typeof n!="object"||n===null)return t;const r=e[o];if(r.endsWith("[]")){const l=r.slice(0,-2);if(l in n){const a=n[l];return Array.isArray(a)?a.map(u=>i(u,e.slice(o+1),t)):t}else return t}else n=n[r]}return n}catch(o){if(o instanceof TypeError)return t;throw o}}function Ut(n,e){for(const[t,o]of Object.entries(e)){const r=t.split("."),l=o.split("."),a=new Set;let u=-1;for(let c=0;c<r.length;c++)if(r[c]==="*"){u=c;break}if(u!==-1&&l.length>u)for(let c=u;c<l.length;c++){const d=l[c];d!=="*"&&!d.endsWith("[]")&&!d.endsWith("[0]")&&a.add(d)}ce(n,r,l,0,a)}}function ce(n,e,t,o,r){if(o>=e.length||typeof n!="object"||n===null)return;const l=e[o];if(l.endsWith("[]")){const a=l.slice(0,-2),u=n;if(a in u&&Array.isArray(u[a]))for(const c of u[a])ce(c,e,t,o+1,r)}else if(l==="*"){if(typeof n=="object"&&n!==null&&!Array.isArray(n)){const a=n,u=Object.keys(a).filter(d=>!d.startsWith("_")&&!r.has(d)),c={};for(const d of u)c[d]=a[d];for(const[d,f]of Object.entries(c)){const p=[];for(const h of t.slice(o))h==="*"?p.push(d):p.push(h);s(a,p,f)}for(const d of u)delete a[d]}}else{const a=n;l in a&&ce(a[l],e,t,o+1,r)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Ce(n){if(typeof n!="string")throw new Error("fromImageBytes must be a string");return n}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function kt(n){const e={},t=i(n,["operationName"]);t!=null&&s(e,["operationName"],t);const o=i(n,["resourceName"]);return o!=null&&s(e,["_url","resourceName"],o),e}function xt(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["metadata"]);o!=null&&s(e,["metadata"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);l!=null&&s(e,["error"],l);const a=i(n,["response","generateVideoResponse"]);return a!=null&&s(e,["response"],Ft(a)),e}function Lt(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["metadata"]);o!=null&&s(e,["metadata"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);l!=null&&s(e,["error"],l);const a=i(n,["response"]);return a!=null&&s(e,["response"],Vt(a)),e}function Ft(n){const e={},t=i(n,["generatedSamples"]);if(t!=null){let l=t;Array.isArray(l)&&(l=l.map(a=>Gt(a))),s(e,["generatedVideos"],l)}const o=i(n,["raiMediaFilteredCount"]);o!=null&&s(e,["raiMediaFilteredCount"],o);const r=i(n,["raiMediaFilteredReasons"]);return r!=null&&s(e,["raiMediaFilteredReasons"],r),e}function Vt(n){const e={},t=i(n,["videos"]);if(t!=null){let l=t;Array.isArray(l)&&(l=l.map(a=>qt(a))),s(e,["generatedVideos"],l)}const o=i(n,["raiMediaFilteredCount"]);o!=null&&s(e,["raiMediaFilteredCount"],o);const r=i(n,["raiMediaFilteredReasons"]);return r!=null&&s(e,["raiMediaFilteredReasons"],r),e}function Gt(n){const e={},t=i(n,["video"]);return t!=null&&s(e,["video"],Wt(t)),e}function qt(n){const e={},t=i(n,["_self"]);return t!=null&&s(e,["video"],$t(t)),e}function Ht(n){const e={},t=i(n,["operationName"]);return t!=null&&s(e,["_url","operationName"],t),e}function Bt(n){const e={},t=i(n,["operationName"]);return t!=null&&s(e,["_url","operationName"],t),e}function Jt(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["metadata"]);o!=null&&s(e,["metadata"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);l!=null&&s(e,["error"],l);const a=i(n,["response"]);return a!=null&&s(e,["response"],bt(a)),e}function bt(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["parent"]);o!=null&&s(e,["parent"],o);const r=i(n,["documentName"]);return r!=null&&s(e,["documentName"],r),e}function nt(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["metadata"]);o!=null&&s(e,["metadata"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);l!=null&&s(e,["error"],l);const a=i(n,["response"]);return a!=null&&s(e,["response"],Yt(a)),e}function Yt(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["parent"]);o!=null&&s(e,["parent"],o);const r=i(n,["documentName"]);return r!=null&&s(e,["documentName"],r),e}function Wt(n){const e={},t=i(n,["uri"]);t!=null&&s(e,["uri"],t);const o=i(n,["encodedVideo"]);o!=null&&s(e,["videoBytes"],Ce(o));const r=i(n,["encoding"]);return r!=null&&s(e,["mimeType"],r),e}function $t(n){const e={},t=i(n,["gcsUri"]);t!=null&&s(e,["uri"],t);const o=i(n,["bytesBase64Encoded"]);o!=null&&s(e,["videoBytes"],Ce(o));const r=i(n,["mimeType"]);return r!=null&&s(e,["mimeType"],r),e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var De;(function(n){n.OUTCOME_UNSPECIFIED="OUTCOME_UNSPECIFIED",n.OUTCOME_OK="OUTCOME_OK",n.OUTCOME_FAILED="OUTCOME_FAILED",n.OUTCOME_DEADLINE_EXCEEDED="OUTCOME_DEADLINE_EXCEEDED"})(De||(De={}));var Ue;(function(n){n.LANGUAGE_UNSPECIFIED="LANGUAGE_UNSPECIFIED",n.PYTHON="PYTHON"})(Ue||(Ue={}));var ke;(function(n){n.SCHEDULING_UNSPECIFIED="SCHEDULING_UNSPECIFIED",n.SILENT="SILENT",n.WHEN_IDLE="WHEN_IDLE",n.INTERRUPT="INTERRUPT"})(ke||(ke={}));var D;(function(n){n.TYPE_UNSPECIFIED="TYPE_UNSPECIFIED",n.STRING="STRING",n.NUMBER="NUMBER",n.INTEGER="INTEGER",n.BOOLEAN="BOOLEAN",n.ARRAY="ARRAY",n.OBJECT="OBJECT",n.NULL="NULL"})(D||(D={}));var xe;(function(n){n.MODE_UNSPECIFIED="MODE_UNSPECIFIED",n.MODE_DYNAMIC="MODE_DYNAMIC"})(xe||(xe={}));var Le;(function(n){n.API_SPEC_UNSPECIFIED="API_SPEC_UNSPECIFIED",n.SIMPLE_SEARCH="SIMPLE_SEARCH",n.ELASTIC_SEARCH="ELASTIC_SEARCH"})(Le||(Le={}));var Fe;(function(n){n.AUTH_TYPE_UNSPECIFIED="AUTH_TYPE_UNSPECIFIED",n.NO_AUTH="NO_AUTH",n.API_KEY_AUTH="API_KEY_AUTH",n.HTTP_BASIC_AUTH="HTTP_BASIC_AUTH",n.GOOGLE_SERVICE_ACCOUNT_AUTH="GOOGLE_SERVICE_ACCOUNT_AUTH",n.OAUTH="OAUTH",n.OIDC_AUTH="OIDC_AUTH"})(Fe||(Fe={}));var Ve;(function(n){n.HTTP_IN_UNSPECIFIED="HTTP_IN_UNSPECIFIED",n.HTTP_IN_QUERY="HTTP_IN_QUERY",n.HTTP_IN_HEADER="HTTP_IN_HEADER",n.HTTP_IN_PATH="HTTP_IN_PATH",n.HTTP_IN_BODY="HTTP_IN_BODY",n.HTTP_IN_COOKIE="HTTP_IN_COOKIE"})(Ve||(Ve={}));var Ge;(function(n){n.PHISH_BLOCK_THRESHOLD_UNSPECIFIED="PHISH_BLOCK_THRESHOLD_UNSPECIFIED",n.BLOCK_LOW_AND_ABOVE="BLOCK_LOW_AND_ABOVE",n.BLOCK_MEDIUM_AND_ABOVE="BLOCK_MEDIUM_AND_ABOVE",n.BLOCK_HIGH_AND_ABOVE="BLOCK_HIGH_AND_ABOVE",n.BLOCK_HIGHER_AND_ABOVE="BLOCK_HIGHER_AND_ABOVE",n.BLOCK_VERY_HIGH_AND_ABOVE="BLOCK_VERY_HIGH_AND_ABOVE",n.BLOCK_ONLY_EXTREMELY_HIGH="BLOCK_ONLY_EXTREMELY_HIGH"})(Ge||(Ge={}));var qe;(function(n){n.HARM_CATEGORY_UNSPECIFIED="HARM_CATEGORY_UNSPECIFIED",n.HARM_CATEGORY_HARASSMENT="HARM_CATEGORY_HARASSMENT",n.HARM_CATEGORY_HATE_SPEECH="HARM_CATEGORY_HATE_SPEECH",n.HARM_CATEGORY_SEXUALLY_EXPLICIT="HARM_CATEGORY_SEXUALLY_EXPLICIT",n.HARM_CATEGORY_DANGEROUS_CONTENT="HARM_CATEGORY_DANGEROUS_CONTENT",n.HARM_CATEGORY_CIVIC_INTEGRITY="HARM_CATEGORY_CIVIC_INTEGRITY",n.HARM_CATEGORY_IMAGE_HATE="HARM_CATEGORY_IMAGE_HATE",n.HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT="HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT",n.HARM_CATEGORY_IMAGE_HARASSMENT="HARM_CATEGORY_IMAGE_HARASSMENT",n.HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT="HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT",n.HARM_CATEGORY_JAILBREAK="HARM_CATEGORY_JAILBREAK"})(qe||(qe={}));var He;(function(n){n.HARM_BLOCK_METHOD_UNSPECIFIED="HARM_BLOCK_METHOD_UNSPECIFIED",n.SEVERITY="SEVERITY",n.PROBABILITY="PROBABILITY"})(He||(He={}));var Be;(function(n){n.HARM_BLOCK_THRESHOLD_UNSPECIFIED="HARM_BLOCK_THRESHOLD_UNSPECIFIED",n.BLOCK_LOW_AND_ABOVE="BLOCK_LOW_AND_ABOVE",n.BLOCK_MEDIUM_AND_ABOVE="BLOCK_MEDIUM_AND_ABOVE",n.BLOCK_ONLY_HIGH="BLOCK_ONLY_HIGH",n.BLOCK_NONE="BLOCK_NONE",n.OFF="OFF"})(Be||(Be={}));var Je;(function(n){n.FINISH_REASON_UNSPECIFIED="FINISH_REASON_UNSPECIFIED",n.STOP="STOP",n.MAX_TOKENS="MAX_TOKENS",n.SAFETY="SAFETY",n.RECITATION="RECITATION",n.LANGUAGE="LANGUAGE",n.OTHER="OTHER",n.BLOCKLIST="BLOCKLIST",n.PROHIBITED_CONTENT="PROHIBITED_CONTENT",n.SPII="SPII",n.MALFORMED_FUNCTION_CALL="MALFORMED_FUNCTION_CALL",n.IMAGE_SAFETY="IMAGE_SAFETY",n.UNEXPECTED_TOOL_CALL="UNEXPECTED_TOOL_CALL",n.IMAGE_PROHIBITED_CONTENT="IMAGE_PROHIBITED_CONTENT",n.NO_IMAGE="NO_IMAGE"})(Je||(Je={}));var be;(function(n){n.HARM_PROBABILITY_UNSPECIFIED="HARM_PROBABILITY_UNSPECIFIED",n.NEGLIGIBLE="NEGLIGIBLE",n.LOW="LOW",n.MEDIUM="MEDIUM",n.HIGH="HIGH"})(be||(be={}));var Ye;(function(n){n.HARM_SEVERITY_UNSPECIFIED="HARM_SEVERITY_UNSPECIFIED",n.HARM_SEVERITY_NEGLIGIBLE="HARM_SEVERITY_NEGLIGIBLE",n.HARM_SEVERITY_LOW="HARM_SEVERITY_LOW",n.HARM_SEVERITY_MEDIUM="HARM_SEVERITY_MEDIUM",n.HARM_SEVERITY_HIGH="HARM_SEVERITY_HIGH"})(Ye||(Ye={}));var We;(function(n){n.URL_RETRIEVAL_STATUS_UNSPECIFIED="URL_RETRIEVAL_STATUS_UNSPECIFIED",n.URL_RETRIEVAL_STATUS_SUCCESS="URL_RETRIEVAL_STATUS_SUCCESS",n.URL_RETRIEVAL_STATUS_ERROR="URL_RETRIEVAL_STATUS_ERROR",n.URL_RETRIEVAL_STATUS_PAYWALL="URL_RETRIEVAL_STATUS_PAYWALL",n.URL_RETRIEVAL_STATUS_UNSAFE="URL_RETRIEVAL_STATUS_UNSAFE"})(We||(We={}));var $e;(function(n){n.BLOCKED_REASON_UNSPECIFIED="BLOCKED_REASON_UNSPECIFIED",n.SAFETY="SAFETY",n.OTHER="OTHER",n.BLOCKLIST="BLOCKLIST",n.PROHIBITED_CONTENT="PROHIBITED_CONTENT",n.IMAGE_SAFETY="IMAGE_SAFETY",n.MODEL_ARMOR="MODEL_ARMOR",n.JAILBREAK="JAILBREAK"})($e||($e={}));var Ke;(function(n){n.TRAFFIC_TYPE_UNSPECIFIED="TRAFFIC_TYPE_UNSPECIFIED",n.ON_DEMAND="ON_DEMAND",n.PROVISIONED_THROUGHPUT="PROVISIONED_THROUGHPUT"})(Ke||(Ke={}));var te;(function(n){n.MODALITY_UNSPECIFIED="MODALITY_UNSPECIFIED",n.TEXT="TEXT",n.IMAGE="IMAGE",n.AUDIO="AUDIO"})(te||(te={}));var ze;(function(n){n.MEDIA_RESOLUTION_UNSPECIFIED="MEDIA_RESOLUTION_UNSPECIFIED",n.MEDIA_RESOLUTION_LOW="MEDIA_RESOLUTION_LOW",n.MEDIA_RESOLUTION_MEDIUM="MEDIA_RESOLUTION_MEDIUM",n.MEDIA_RESOLUTION_HIGH="MEDIA_RESOLUTION_HIGH"})(ze||(ze={}));var Oe;(function(n){n.TUNING_MODE_UNSPECIFIED="TUNING_MODE_UNSPECIFIED",n.TUNING_MODE_FULL="TUNING_MODE_FULL",n.TUNING_MODE_PEFT_ADAPTER="TUNING_MODE_PEFT_ADAPTER"})(Oe||(Oe={}));var Xe;(function(n){n.ADAPTER_SIZE_UNSPECIFIED="ADAPTER_SIZE_UNSPECIFIED",n.ADAPTER_SIZE_ONE="ADAPTER_SIZE_ONE",n.ADAPTER_SIZE_TWO="ADAPTER_SIZE_TWO",n.ADAPTER_SIZE_FOUR="ADAPTER_SIZE_FOUR",n.ADAPTER_SIZE_EIGHT="ADAPTER_SIZE_EIGHT",n.ADAPTER_SIZE_SIXTEEN="ADAPTER_SIZE_SIXTEEN",n.ADAPTER_SIZE_THIRTY_TWO="ADAPTER_SIZE_THIRTY_TWO"})(Xe||(Xe={}));var fe;(function(n){n.JOB_STATE_UNSPECIFIED="JOB_STATE_UNSPECIFIED",n.JOB_STATE_QUEUED="JOB_STATE_QUEUED",n.JOB_STATE_PENDING="JOB_STATE_PENDING",n.JOB_STATE_RUNNING="JOB_STATE_RUNNING",n.JOB_STATE_SUCCEEDED="JOB_STATE_SUCCEEDED",n.JOB_STATE_FAILED="JOB_STATE_FAILED",n.JOB_STATE_CANCELLING="JOB_STATE_CANCELLING",n.JOB_STATE_CANCELLED="JOB_STATE_CANCELLED",n.JOB_STATE_PAUSED="JOB_STATE_PAUSED",n.JOB_STATE_EXPIRED="JOB_STATE_EXPIRED",n.JOB_STATE_UPDATING="JOB_STATE_UPDATING",n.JOB_STATE_PARTIALLY_SUCCEEDED="JOB_STATE_PARTIALLY_SUCCEEDED"})(fe||(fe={}));var Qe;(function(n){n.TUNING_TASK_UNSPECIFIED="TUNING_TASK_UNSPECIFIED",n.TUNING_TASK_I2V="TUNING_TASK_I2V",n.TUNING_TASK_T2V="TUNING_TASK_T2V",n.TUNING_TASK_R2V="TUNING_TASK_R2V"})(Qe||(Qe={}));var Ze;(function(n){n.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED="FEATURE_SELECTION_PREFERENCE_UNSPECIFIED",n.PRIORITIZE_QUALITY="PRIORITIZE_QUALITY",n.BALANCED="BALANCED",n.PRIORITIZE_COST="PRIORITIZE_COST"})(Ze||(Ze={}));var je;(function(n){n.UNSPECIFIED="UNSPECIFIED",n.BLOCKING="BLOCKING",n.NON_BLOCKING="NON_BLOCKING"})(je||(je={}));var en;(function(n){n.MODE_UNSPECIFIED="MODE_UNSPECIFIED",n.MODE_DYNAMIC="MODE_DYNAMIC"})(en||(en={}));var nn;(function(n){n.ENVIRONMENT_UNSPECIFIED="ENVIRONMENT_UNSPECIFIED",n.ENVIRONMENT_BROWSER="ENVIRONMENT_BROWSER"})(nn||(nn={}));var tn;(function(n){n.MODE_UNSPECIFIED="MODE_UNSPECIFIED",n.AUTO="AUTO",n.ANY="ANY",n.NONE="NONE",n.VALIDATED="VALIDATED"})(tn||(tn={}));var on;(function(n){n.BLOCK_LOW_AND_ABOVE="BLOCK_LOW_AND_ABOVE",n.BLOCK_MEDIUM_AND_ABOVE="BLOCK_MEDIUM_AND_ABOVE",n.BLOCK_ONLY_HIGH="BLOCK_ONLY_HIGH",n.BLOCK_NONE="BLOCK_NONE"})(on||(on={}));var sn;(function(n){n.DONT_ALLOW="DONT_ALLOW",n.ALLOW_ADULT="ALLOW_ADULT",n.ALLOW_ALL="ALLOW_ALL"})(sn||(sn={}));var rn;(function(n){n.auto="auto",n.en="en",n.ja="ja",n.ko="ko",n.hi="hi",n.zh="zh",n.pt="pt",n.es="es"})(rn||(rn={}));var ln;(function(n){n.MASK_MODE_DEFAULT="MASK_MODE_DEFAULT",n.MASK_MODE_USER_PROVIDED="MASK_MODE_USER_PROVIDED",n.MASK_MODE_BACKGROUND="MASK_MODE_BACKGROUND",n.MASK_MODE_FOREGROUND="MASK_MODE_FOREGROUND",n.MASK_MODE_SEMANTIC="MASK_MODE_SEMANTIC"})(ln||(ln={}));var an;(function(n){n.CONTROL_TYPE_DEFAULT="CONTROL_TYPE_DEFAULT",n.CONTROL_TYPE_CANNY="CONTROL_TYPE_CANNY",n.CONTROL_TYPE_SCRIBBLE="CONTROL_TYPE_SCRIBBLE",n.CONTROL_TYPE_FACE_MESH="CONTROL_TYPE_FACE_MESH"})(an||(an={}));var un;(function(n){n.SUBJECT_TYPE_DEFAULT="SUBJECT_TYPE_DEFAULT",n.SUBJECT_TYPE_PERSON="SUBJECT_TYPE_PERSON",n.SUBJECT_TYPE_ANIMAL="SUBJECT_TYPE_ANIMAL",n.SUBJECT_TYPE_PRODUCT="SUBJECT_TYPE_PRODUCT"})(un||(un={}));var dn;(function(n){n.EDIT_MODE_DEFAULT="EDIT_MODE_DEFAULT",n.EDIT_MODE_INPAINT_REMOVAL="EDIT_MODE_INPAINT_REMOVAL",n.EDIT_MODE_INPAINT_INSERTION="EDIT_MODE_INPAINT_INSERTION",n.EDIT_MODE_OUTPAINT="EDIT_MODE_OUTPAINT",n.EDIT_MODE_CONTROLLED_EDITING="EDIT_MODE_CONTROLLED_EDITING",n.EDIT_MODE_STYLE="EDIT_MODE_STYLE",n.EDIT_MODE_BGSWAP="EDIT_MODE_BGSWAP",n.EDIT_MODE_PRODUCT_IMAGE="EDIT_MODE_PRODUCT_IMAGE"})(dn||(dn={}));var cn;(function(n){n.FOREGROUND="FOREGROUND",n.BACKGROUND="BACKGROUND",n.PROMPT="PROMPT",n.SEMANTIC="SEMANTIC",n.INTERACTIVE="INTERACTIVE"})(cn||(cn={}));var fn;(function(n){n.ASSET="ASSET",n.STYLE="STYLE"})(fn||(fn={}));var pn;(function(n){n.INSERT="INSERT",n.REMOVE="REMOVE",n.REMOVE_STATIC="REMOVE_STATIC",n.OUTPAINT="OUTPAINT"})(pn||(pn={}));var hn;(function(n){n.OPTIMIZED="OPTIMIZED",n.LOSSLESS="LOSSLESS"})(hn||(hn={}));var mn;(function(n){n.SUPERVISED_FINE_TUNING="SUPERVISED_FINE_TUNING",n.PREFERENCE_TUNING="PREFERENCE_TUNING"})(mn||(mn={}));var gn;(function(n){n.STATE_UNSPECIFIED="STATE_UNSPECIFIED",n.STATE_PENDING="STATE_PENDING",n.STATE_ACTIVE="STATE_ACTIVE",n.STATE_FAILED="STATE_FAILED"})(gn||(gn={}));var Tn;(function(n){n.STATE_UNSPECIFIED="STATE_UNSPECIFIED",n.PROCESSING="PROCESSING",n.ACTIVE="ACTIVE",n.FAILED="FAILED"})(Tn||(Tn={}));var yn;(function(n){n.SOURCE_UNSPECIFIED="SOURCE_UNSPECIFIED",n.UPLOADED="UPLOADED",n.GENERATED="GENERATED"})(yn||(yn={}));var En;(function(n){n.TURN_COMPLETE_REASON_UNSPECIFIED="TURN_COMPLETE_REASON_UNSPECIFIED",n.MALFORMED_FUNCTION_CALL="MALFORMED_FUNCTION_CALL",n.RESPONSE_REJECTED="RESPONSE_REJECTED",n.NEED_MORE_INPUT="NEED_MORE_INPUT"})(En||(En={}));var Cn;(function(n){n.MODALITY_UNSPECIFIED="MODALITY_UNSPECIFIED",n.TEXT="TEXT",n.IMAGE="IMAGE",n.VIDEO="VIDEO",n.AUDIO="AUDIO",n.DOCUMENT="DOCUMENT"})(Cn||(Cn={}));var _n;(function(n){n.START_SENSITIVITY_UNSPECIFIED="START_SENSITIVITY_UNSPECIFIED",n.START_SENSITIVITY_HIGH="START_SENSITIVITY_HIGH",n.START_SENSITIVITY_LOW="START_SENSITIVITY_LOW"})(_n||(_n={}));var Sn;(function(n){n.END_SENSITIVITY_UNSPECIFIED="END_SENSITIVITY_UNSPECIFIED",n.END_SENSITIVITY_HIGH="END_SENSITIVITY_HIGH",n.END_SENSITIVITY_LOW="END_SENSITIVITY_LOW"})(Sn||(Sn={}));var In;(function(n){n.ACTIVITY_HANDLING_UNSPECIFIED="ACTIVITY_HANDLING_UNSPECIFIED",n.START_OF_ACTIVITY_INTERRUPTS="START_OF_ACTIVITY_INTERRUPTS",n.NO_INTERRUPTION="NO_INTERRUPTION"})(In||(In={}));var vn;(function(n){n.TURN_COVERAGE_UNSPECIFIED="TURN_COVERAGE_UNSPECIFIED",n.TURN_INCLUDES_ONLY_ACTIVITY="TURN_INCLUDES_ONLY_ACTIVITY",n.TURN_INCLUDES_ALL_INPUT="TURN_INCLUDES_ALL_INPUT"})(vn||(vn={}));var An;(function(n){n.SCALE_UNSPECIFIED="SCALE_UNSPECIFIED",n.C_MAJOR_A_MINOR="C_MAJOR_A_MINOR",n.D_FLAT_MAJOR_B_FLAT_MINOR="D_FLAT_MAJOR_B_FLAT_MINOR",n.D_MAJOR_B_MINOR="D_MAJOR_B_MINOR",n.E_FLAT_MAJOR_C_MINOR="E_FLAT_MAJOR_C_MINOR",n.E_MAJOR_D_FLAT_MINOR="E_MAJOR_D_FLAT_MINOR",n.F_MAJOR_D_MINOR="F_MAJOR_D_MINOR",n.G_FLAT_MAJOR_E_FLAT_MINOR="G_FLAT_MAJOR_E_FLAT_MINOR",n.G_MAJOR_E_MINOR="G_MAJOR_E_MINOR",n.A_FLAT_MAJOR_F_MINOR="A_FLAT_MAJOR_F_MINOR",n.A_MAJOR_G_FLAT_MINOR="A_MAJOR_G_FLAT_MINOR",n.B_FLAT_MAJOR_G_MINOR="B_FLAT_MAJOR_G_MINOR",n.B_MAJOR_A_FLAT_MINOR="B_MAJOR_A_FLAT_MINOR"})(An||(An={}));var Rn;(function(n){n.MUSIC_GENERATION_MODE_UNSPECIFIED="MUSIC_GENERATION_MODE_UNSPECIFIED",n.QUALITY="QUALITY",n.DIVERSITY="DIVERSITY",n.VOCALIZATION="VOCALIZATION"})(Rn||(Rn={}));var W;(function(n){n.PLAYBACK_CONTROL_UNSPECIFIED="PLAYBACK_CONTROL_UNSPECIFIED",n.PLAY="PLAY",n.PAUSE="PAUSE",n.STOP="STOP",n.RESET_CONTEXT="RESET_CONTEXT"})(W||(W={}));class pe{constructor(e){const t={};for(const o of e.headers.entries())t[o[0]]=o[1];this.headers=t,this.responseInternal=e}json(){return this.responseInternal.json()}}class Z{get text(){var e,t,o,r,l,a,u,c;if(((r=(o=(t=(e=this.candidates)===null||e===void 0?void 0:e[0])===null||t===void 0?void 0:t.content)===null||o===void 0?void 0:o.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning text from the first one.");let d="",f=!1;const p=[];for(const h of(c=(u=(a=(l=this.candidates)===null||l===void 0?void 0:l[0])===null||a===void 0?void 0:a.content)===null||u===void 0?void 0:u.parts)!==null&&c!==void 0?c:[]){for(const[m,g]of Object.entries(h))m!=="text"&&m!=="thought"&&m!=="thoughtSignature"&&(g!==null||g!==void 0)&&p.push(m);if(typeof h.text=="string"){if(typeof h.thought=="boolean"&&h.thought)continue;f=!0,d+=h.text}}return p.length>0&&console.warn(`there are non-text parts ${p} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`),f?d:void 0}get data(){var e,t,o,r,l,a,u,c;if(((r=(o=(t=(e=this.candidates)===null||e===void 0?void 0:e[0])===null||t===void 0?void 0:t.content)===null||o===void 0?void 0:o.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning data from the first one.");let d="";const f=[];for(const p of(c=(u=(a=(l=this.candidates)===null||l===void 0?void 0:l[0])===null||a===void 0?void 0:a.content)===null||u===void 0?void 0:u.parts)!==null&&c!==void 0?c:[]){for(const[h,m]of Object.entries(p))h!=="inlineData"&&(m!==null||m!==void 0)&&f.push(h);p.inlineData&&typeof p.inlineData.data=="string"&&(d+=atob(p.inlineData.data))}return f.length>0&&console.warn(`there are non-data parts ${f} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`),d.length>0?btoa(d):void 0}get functionCalls(){var e,t,o,r,l,a,u,c;if(((r=(o=(t=(e=this.candidates)===null||e===void 0?void 0:e[0])===null||t===void 0?void 0:t.content)===null||o===void 0?void 0:o.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning function calls from the first one.");const d=(c=(u=(a=(l=this.candidates)===null||l===void 0?void 0:l[0])===null||a===void 0?void 0:a.content)===null||u===void 0?void 0:u.parts)===null||c===void 0?void 0:c.filter(f=>f.functionCall).map(f=>f.functionCall).filter(f=>f!==void 0);if((d==null?void 0:d.length)!==0)return d}get executableCode(){var e,t,o,r,l,a,u,c,d;if(((r=(o=(t=(e=this.candidates)===null||e===void 0?void 0:e[0])===null||t===void 0?void 0:t.content)===null||o===void 0?void 0:o.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning executable code from the first one.");const f=(c=(u=(a=(l=this.candidates)===null||l===void 0?void 0:l[0])===null||a===void 0?void 0:a.content)===null||u===void 0?void 0:u.parts)===null||c===void 0?void 0:c.filter(p=>p.executableCode).map(p=>p.executableCode).filter(p=>p!==void 0);if((f==null?void 0:f.length)!==0)return(d=f==null?void 0:f[0])===null||d===void 0?void 0:d.code}get codeExecutionResult(){var e,t,o,r,l,a,u,c,d;if(((r=(o=(t=(e=this.candidates)===null||e===void 0?void 0:e[0])===null||t===void 0?void 0:t.content)===null||o===void 0?void 0:o.parts)===null||r===void 0?void 0:r.length)===0)return;this.candidates&&this.candidates.length>1&&console.warn("there are multiple candidates in the response, returning code execution result from the first one.");const f=(c=(u=(a=(l=this.candidates)===null||l===void 0?void 0:l[0])===null||a===void 0?void 0:a.content)===null||u===void 0?void 0:u.parts)===null||c===void 0?void 0:c.filter(p=>p.codeExecutionResult).map(p=>p.codeExecutionResult).filter(p=>p!==void 0);if((f==null?void 0:f.length)!==0)return(d=f==null?void 0:f[0])===null||d===void 0?void 0:d.output}}class Pn{}class Mn{}class Kt{}class zt{}class Ot{}class Xt{}class Nn{}class wn{}class Dn{}class Qt{}class oe{_fromAPIResponse({apiResponse:e,_isVertexAI:t}){const o=new oe;let r;const l=e;return t?r=Lt(l):r=xt(l),Object.assign(o,r),o}}class Un{}class kn{}class xn{}class Zt{}class jt{}class eo{}class _e{_fromAPIResponse({apiResponse:e,_isVertexAI:t}){const o=new _e,l=Jt(e);return Object.assign(o,l),o}}class no{}class to{}class oo{}class Ln{}class io{get text(){var e,t,o;let r="",l=!1;const a=[];for(const u of(o=(t=(e=this.serverContent)===null||e===void 0?void 0:e.modelTurn)===null||t===void 0?void 0:t.parts)!==null&&o!==void 0?o:[]){for(const[c,d]of Object.entries(u))c!=="text"&&c!=="thought"&&d!==null&&a.push(c);if(typeof u.text=="string"){if(typeof u.thought=="boolean"&&u.thought)continue;l=!0,r+=u.text}}return a.length>0&&console.warn(`there are non-text parts ${a} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`),l?r:void 0}get data(){var e,t,o;let r="";const l=[];for(const a of(o=(t=(e=this.serverContent)===null||e===void 0?void 0:e.modelTurn)===null||t===void 0?void 0:t.parts)!==null&&o!==void 0?o:[]){for(const[u,c]of Object.entries(a))u!=="inlineData"&&c!==null&&l.push(u);a.inlineData&&typeof a.inlineData.data=="string"&&(r+=atob(a.inlineData.data))}return l.length>0&&console.warn(`there are non-data parts ${l} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`),r.length>0?btoa(r):void 0}}class so{get audioChunk(){if(this.serverContent&&this.serverContent.audioChunks&&this.serverContent.audioChunks.length>0)return this.serverContent.audioChunks[0]}}class Se{_fromAPIResponse({apiResponse:e,_isVertexAI:t}){const o=new Se,l=nt(e);return Object.assign(o,l),o}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function M(n,e){if(!e||typeof e!="string")throw new Error("model is required and must be a string");if(e.includes("..")||e.includes("?")||e.includes("&"))throw new Error("invalid model parameter");if(n.isVertexAI()){if(e.startsWith("publishers/")||e.startsWith("projects/")||e.startsWith("models/"))return e;if(e.indexOf("/")>=0){const t=e.split("/",2);return`publishers/${t[0]}/models/${t[1]}`}else return`publishers/google/models/${e}`}else return e.startsWith("models/")||e.startsWith("tunedModels/")?e:`models/${e}`}function tt(n,e){const t=M(n,e);return t?t.startsWith("publishers/")&&n.isVertexAI()?`projects/${n.getProject()}/locations/${n.getLocation()}/${t}`:t.startsWith("models/")&&n.isVertexAI()?`projects/${n.getProject()}/locations/${n.getLocation()}/publishers/google/${t}`:t:""}function ot(n){return Array.isArray(n)?n.map(e=>ie(e)):[ie(n)]}function ie(n){if(typeof n=="object"&&n!==null)return n;throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof n}`)}function it(n){const e=ie(n);if(e.mimeType&&e.mimeType.startsWith("image/"))return e;throw new Error(`Unsupported mime type: ${e.mimeType}`)}function st(n){const e=ie(n);if(e.mimeType&&e.mimeType.startsWith("audio/"))return e;throw new Error(`Unsupported mime type: ${e.mimeType}`)}function Fn(n){if(n==null)throw new Error("PartUnion is required");if(typeof n=="object")return n;if(typeof n=="string")return{text:n};throw new Error(`Unsupported part type: ${typeof n}`)}function rt(n){if(n==null||Array.isArray(n)&&n.length===0)throw new Error("PartListUnion is required");return Array.isArray(n)?n.map(e=>Fn(e)):[Fn(n)]}function he(n){return n!=null&&typeof n=="object"&&"parts"in n&&Array.isArray(n.parts)}function Vn(n){return n!=null&&typeof n=="object"&&"functionCall"in n}function Gn(n){return n!=null&&typeof n=="object"&&"functionResponse"in n}function L(n){if(n==null)throw new Error("ContentUnion is required");return he(n)?n:{role:"user",parts:rt(n)}}function Ie(n,e){if(!e)return[];if(n.isVertexAI()&&Array.isArray(e))return e.flatMap(t=>{const o=L(t);return o.parts&&o.parts.length>0&&o.parts[0].text!==void 0?[o.parts[0].text]:[]});if(n.isVertexAI()){const t=L(e);return t.parts&&t.parts.length>0&&t.parts[0].text!==void 0?[t.parts[0].text]:[]}return Array.isArray(e)?e.map(t=>L(t)):[L(e)]}function F(n){if(n==null||Array.isArray(n)&&n.length===0)throw new Error("contents are required");if(!Array.isArray(n)){if(Vn(n)||Gn(n))throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");return[L(n)]}const e=[],t=[],o=he(n[0]);for(const r of n){const l=he(r);if(l!=o)throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");if(l)e.push(r);else{if(Vn(r)||Gn(r))throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");t.push(r)}}return o||e.push({role:"user",parts:rt(t)}),e}function ro(n,e){n.includes("null")&&(e.nullable=!0);const t=n.filter(o=>o!=="null");if(t.length===1)e.type=Object.values(D).includes(t[0].toUpperCase())?t[0].toUpperCase():D.TYPE_UNSPECIFIED;else{e.anyOf=[];for(const o of t)e.anyOf.push({type:Object.values(D).includes(o.toUpperCase())?o.toUpperCase():D.TYPE_UNSPECIFIED})}}function $(n){const e={},t=["items"],o=["anyOf"],r=["properties"];if(n.type&&n.anyOf)throw new Error("type and anyOf cannot be both populated.");const l=n.anyOf;l!=null&&l.length==2&&(l[0].type==="null"?(e.nullable=!0,n=l[1]):l[1].type==="null"&&(e.nullable=!0,n=l[0])),n.type instanceof Array&&ro(n.type,e);for(const[a,u]of Object.entries(n))if(u!=null)if(a=="type"){if(u==="null")throw new Error("type: null can not be the only possible type for the field.");if(u instanceof Array)continue;e.type=Object.values(D).includes(u.toUpperCase())?u.toUpperCase():D.TYPE_UNSPECIFIED}else if(t.includes(a))e[a]=$(u);else if(o.includes(a)){const c=[];for(const d of u){if(d.type=="null"){e.nullable=!0;continue}c.push($(d))}e[a]=c}else if(r.includes(a)){const c={};for(const[d,f]of Object.entries(u))c[d]=$(f);e[a]=c}else{if(a==="additionalProperties")continue;e[a]=u}return e}function ve(n){return $(n)}function Ae(n){if(typeof n=="object")return n;if(typeof n=="string")return{voiceConfig:{prebuiltVoiceConfig:{voiceName:n}}};throw new Error(`Unsupported speechConfig type: ${typeof n}`)}function Re(n){if("multiSpeakerVoiceConfig"in n)throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");return n}function O(n){if(n.functionDeclarations)for(const e of n.functionDeclarations)e.parameters&&(Object.keys(e.parameters).includes("$schema")?e.parametersJsonSchema||(e.parametersJsonSchema=e.parameters,delete e.parameters):e.parameters=$(e.parameters)),e.response&&(Object.keys(e.response).includes("$schema")?e.responseJsonSchema||(e.responseJsonSchema=e.response,delete e.response):e.response=$(e.response));return n}function X(n){if(n==null)throw new Error("tools is required");if(!Array.isArray(n))throw new Error("tools is required and must be an array of Tools");const e=[];for(const t of n)e.push(t);return e}function lo(n,e,t,o=1){const r=!e.startsWith(`${t}/`)&&e.split("/").length===o;return n.isVertexAI()?e.startsWith("projects/")?e:e.startsWith("locations/")?`projects/${n.getProject()}/${e}`:e.startsWith(`${t}/`)?`projects/${n.getProject()}/locations/${n.getLocation()}/${e}`:r?`projects/${n.getProject()}/locations/${n.getLocation()}/${t}/${e}`:e:r?`${t}/${e}`:e}function J(n,e){if(typeof e!="string")throw new Error("name must be a string");return lo(n,e,"cachedContents")}function lt(n){switch(n){case"STATE_UNSPECIFIED":return"JOB_STATE_UNSPECIFIED";case"CREATING":return"JOB_STATE_RUNNING";case"ACTIVE":return"JOB_STATE_SUCCEEDED";case"FAILED":return"JOB_STATE_FAILED";default:return n}}function b(n){return Ce(n)}function ao(n){return n!=null&&typeof n=="object"&&"name"in n}function uo(n){return n!=null&&typeof n=="object"&&"video"in n}function co(n){return n!=null&&typeof n=="object"&&"uri"in n}function at(n){var e;let t;if(ao(n)&&(t=n.name),!(co(n)&&(t=n.uri,t===void 0))&&!(uo(n)&&(t=(e=n.video)===null||e===void 0?void 0:e.uri,t===void 0))){if(typeof n=="string"&&(t=n),t===void 0)throw new Error("Could not extract file name from the provided input.");if(t.startsWith("https://")){const r=t.split("files/")[1].match(/[a-z0-9]+/);if(r===null)throw new Error(`Could not extract file name from URI ${t}`);t=r[0]}else t.startsWith("files/")&&(t=t.split("files/")[1]);return t}}function ut(n,e){let t;return n.isVertexAI()?t=e?"publishers/google/models":"models":t=e?"models":"tunedModels",t}function dt(n){for(const e of["models","tunedModels","publisherModels"])if(fo(n,e))return n[e];return[]}function fo(n,e){return n!==null&&typeof n=="object"&&e in n}function po(n,e={}){const t=n,o={name:t.name,description:t.description,parametersJsonSchema:t.inputSchema};return t.outputSchema&&(o.responseJsonSchema=t.outputSchema),e.behavior&&(o.behavior=e.behavior),{functionDeclarations:[o]}}function ho(n,e={}){const t=[],o=new Set;for(const r of n){const l=r.name;if(o.has(l))throw new Error(`Duplicate function name ${l} found in MCP tools. Please ensure function names are unique.`);o.add(l);const a=po(r,e);a.functionDeclarations&&t.push(...a.functionDeclarations)}return{functionDeclarations:t}}function ct(n,e){let t;if(typeof e=="string")if(n.isVertexAI())if(e.startsWith("gs://"))t={format:"jsonl",gcsUri:[e]};else if(e.startsWith("bq://"))t={format:"bigquery",bigqueryUri:e};else throw new Error(`Unsupported string source for Vertex AI: ${e}`);else if(e.startsWith("files/"))t={fileName:e};else throw new Error(`Unsupported string source for Gemini API: ${e}`);else if(Array.isArray(e)){if(n.isVertexAI())throw new Error("InlinedRequest[] is not supported in Vertex AI.");t={inlinedRequests:e}}else t=e;const o=[t.gcsUri,t.bigqueryUri].filter(Boolean).length,r=[t.inlinedRequests,t.fileName].filter(Boolean).length;if(n.isVertexAI()){if(r>0||o!==1)throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.")}else if(o>0||r!==1)throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");return t}function mo(n){if(typeof n!="string")return n;const e=n;if(e.startsWith("gs://"))return{format:"jsonl",gcsUri:e};if(e.startsWith("bq://"))return{format:"bigquery",bigqueryUri:e};throw new Error(`Unsupported destination: ${e}`)}function ft(n){if(typeof n!="object"||n===null)return{};const e=n,t=e.inlinedResponses;if(typeof t!="object"||t===null)return n;const r=t.inlinedResponses;if(!Array.isArray(r)||r.length===0)return n;let l=!1;for(const a of r){if(typeof a!="object"||a===null)continue;const c=a.response;if(typeof c!="object"||c===null)continue;if(c.embedding!==void 0){l=!0;break}}return l&&(e.inlinedEmbedContentResponses=e.inlinedResponses,delete e.inlinedResponses),n}function Q(n,e){const t=e;if(!n.isVertexAI()){if(/batches\/[^/]+$/.test(t))return t.split("/").pop();throw new Error(`Invalid batch job name: ${t}.`)}if(/^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/.test(t))return t.split("/").pop();if(/^\d+$/.test(t))return t;throw new Error(`Invalid batch job name: ${t}.`)}function pt(n){const e=n;return e==="BATCH_STATE_UNSPECIFIED"?"JOB_STATE_UNSPECIFIED":e==="BATCH_STATE_PENDING"?"JOB_STATE_PENDING":e==="BATCH_STATE_RUNNING"?"JOB_STATE_RUNNING":e==="BATCH_STATE_SUCCEEDED"?"JOB_STATE_SUCCEEDED":e==="BATCH_STATE_FAILED"?"JOB_STATE_FAILED":e==="BATCH_STATE_CANCELLED"?"JOB_STATE_CANCELLED":e==="BATCH_STATE_EXPIRED"?"JOB_STATE_EXPIRED":e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function go(n){const e={},t=i(n,["responsesFile"]);t!=null&&s(e,["fileName"],t);const o=i(n,["inlinedResponses","inlinedResponses"]);if(o!=null){let l=o;Array.isArray(l)&&(l=l.map(a=>Ko(a))),s(e,["inlinedResponses"],l)}const r=i(n,["inlinedEmbedContentResponses","inlinedResponses"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>a)),s(e,["inlinedEmbedContentResponses"],l)}return e}function To(n){const e={},t=i(n,["predictionsFormat"]);t!=null&&s(e,["format"],t);const o=i(n,["gcsDestination","outputUriPrefix"]);o!=null&&s(e,["gcsUri"],o);const r=i(n,["bigqueryDestination","outputUri"]);return r!=null&&s(e,["bigqueryUri"],r),e}function yo(n){const e={},t=i(n,["format"]);t!=null&&s(e,["predictionsFormat"],t);const o=i(n,["gcsUri"]);o!=null&&s(e,["gcsDestination","outputUriPrefix"],o);const r=i(n,["bigqueryUri"]);if(r!=null&&s(e,["bigqueryDestination","outputUri"],r),i(n,["fileName"])!==void 0)throw new Error("fileName parameter is not supported in Vertex AI.");if(i(n,["inlinedResponses"])!==void 0)throw new Error("inlinedResponses parameter is not supported in Vertex AI.");if(i(n,["inlinedEmbedContentResponses"])!==void 0)throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");return e}function ee(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["metadata","displayName"]);o!=null&&s(e,["displayName"],o);const r=i(n,["metadata","state"]);r!=null&&s(e,["state"],pt(r));const l=i(n,["metadata","createTime"]);l!=null&&s(e,["createTime"],l);const a=i(n,["metadata","endTime"]);a!=null&&s(e,["endTime"],a);const u=i(n,["metadata","updateTime"]);u!=null&&s(e,["updateTime"],u);const c=i(n,["metadata","model"]);c!=null&&s(e,["model"],c);const d=i(n,["metadata","output"]);return d!=null&&s(e,["dest"],go(ft(d))),e}function me(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["displayName"]);o!=null&&s(e,["displayName"],o);const r=i(n,["state"]);r!=null&&s(e,["state"],pt(r));const l=i(n,["error"]);l!=null&&s(e,["error"],l);const a=i(n,["createTime"]);a!=null&&s(e,["createTime"],a);const u=i(n,["startTime"]);u!=null&&s(e,["startTime"],u);const c=i(n,["endTime"]);c!=null&&s(e,["endTime"],c);const d=i(n,["updateTime"]);d!=null&&s(e,["updateTime"],d);const f=i(n,["model"]);f!=null&&s(e,["model"],f);const p=i(n,["inputConfig"]);p!=null&&s(e,["src"],Eo(p));const h=i(n,["outputConfig"]);h!=null&&s(e,["dest"],To(ft(h)));const m=i(n,["completionStats"]);return m!=null&&s(e,["completionStats"],m),e}function Eo(n){const e={},t=i(n,["instancesFormat"]);t!=null&&s(e,["format"],t);const o=i(n,["gcsSource","uris"]);o!=null&&s(e,["gcsUri"],o);const r=i(n,["bigquerySource","inputUri"]);return r!=null&&s(e,["bigqueryUri"],r),e}function Co(n,e){const t={};if(i(e,["format"])!==void 0)throw new Error("format parameter is not supported in Gemini API.");if(i(e,["gcsUri"])!==void 0)throw new Error("gcsUri parameter is not supported in Gemini API.");if(i(e,["bigqueryUri"])!==void 0)throw new Error("bigqueryUri parameter is not supported in Gemini API.");const o=i(e,["fileName"]);o!=null&&s(t,["fileName"],o);const r=i(e,["inlinedRequests"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>$o(n,a))),s(t,["requests","requests"],l)}return t}function _o(n){const e={},t=i(n,["format"]);t!=null&&s(e,["instancesFormat"],t);const o=i(n,["gcsUri"]);o!=null&&s(e,["gcsSource","uris"],o);const r=i(n,["bigqueryUri"]);if(r!=null&&s(e,["bigquerySource","inputUri"],r),i(n,["fileName"])!==void 0)throw new Error("fileName parameter is not supported in Vertex AI.");if(i(n,["inlinedRequests"])!==void 0)throw new Error("inlinedRequests parameter is not supported in Vertex AI.");return e}function So(n){const e={},t=i(n,["data"]);if(t!=null&&s(e,["data"],t),i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function Io(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],Q(n,o)),t}function vo(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],Q(n,o)),t}function Ao(n){const e={},t=i(n,["content"]);t!=null&&s(e,["content"],t);const o=i(n,["citationMetadata"]);o!=null&&s(e,["citationMetadata"],Ro(o));const r=i(n,["tokenCount"]);r!=null&&s(e,["tokenCount"],r);const l=i(n,["finishReason"]);l!=null&&s(e,["finishReason"],l);const a=i(n,["avgLogprobs"]);a!=null&&s(e,["avgLogprobs"],a);const u=i(n,["groundingMetadata"]);u!=null&&s(e,["groundingMetadata"],u);const c=i(n,["index"]);c!=null&&s(e,["index"],c);const d=i(n,["logprobsResult"]);d!=null&&s(e,["logprobsResult"],d);const f=i(n,["safetyRatings"]);if(f!=null){let h=f;Array.isArray(h)&&(h=h.map(m=>m)),s(e,["safetyRatings"],h)}const p=i(n,["urlContextMetadata"]);return p!=null&&s(e,["urlContextMetadata"],p),e}function Ro(n){const e={},t=i(n,["citationSources"]);if(t!=null){let o=t;Array.isArray(o)&&(o=o.map(r=>r)),s(e,["citations"],o)}return e}function ht(n){const e={},t=i(n,["parts"]);if(t!=null){let r=t;Array.isArray(r)&&(r=r.map(l=>ei(l))),s(e,["parts"],r)}const o=i(n,["role"]);return o!=null&&s(e,["role"],o),e}function Po(n,e){const t={},o=i(n,["displayName"]);if(e!==void 0&&o!=null&&s(e,["batch","displayName"],o),i(n,["dest"])!==void 0)throw new Error("dest parameter is not supported in Gemini API.");return t}function Mo(n,e){const t={},o=i(n,["displayName"]);e!==void 0&&o!=null&&s(e,["displayName"],o);const r=i(n,["dest"]);return e!==void 0&&r!=null&&s(e,["outputConfig"],yo(mo(r))),t}function qn(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["src"]);r!=null&&s(t,["batch","inputConfig"],Co(n,ct(n,r)));const l=i(e,["config"]);return l!=null&&Po(l,t),t}function No(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["model"],M(n,o));const r=i(e,["src"]);r!=null&&s(t,["inputConfig"],_o(ct(n,r)));const l=i(e,["config"]);return l!=null&&Mo(l,t),t}function wo(n,e){const t={},o=i(n,["displayName"]);return e!==void 0&&o!=null&&s(e,["batch","displayName"],o),t}function Do(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["src"]);r!=null&&s(t,["batch","inputConfig"],Go(n,r));const l=i(e,["config"]);return l!=null&&wo(l,t),t}function Uo(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],Q(n,o)),t}function ko(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],Q(n,o)),t}function xo(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["name"]);o!=null&&s(e,["name"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);return l!=null&&s(e,["error"],l),e}function Lo(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["name"]);o!=null&&s(e,["name"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);return l!=null&&s(e,["error"],l),e}function Fo(n,e){const t={},o=i(e,["contents"]);if(o!=null){let l=Ie(n,o);Array.isArray(l)&&(l=l.map(a=>a)),s(t,["requests[]","request","content"],l)}const r=i(e,["config"]);return r!=null&&(s(t,["_self"],Vo(r,t)),Ut(t,{"requests[].*":"requests[].request.*"})),t}function Vo(n,e){const t={},o=i(n,["taskType"]);e!==void 0&&o!=null&&s(e,["requests[]","taskType"],o);const r=i(n,["title"]);e!==void 0&&r!=null&&s(e,["requests[]","title"],r);const l=i(n,["outputDimensionality"]);if(e!==void 0&&l!=null&&s(e,["requests[]","outputDimensionality"],l),i(n,["mimeType"])!==void 0)throw new Error("mimeType parameter is not supported in Gemini API.");if(i(n,["autoTruncate"])!==void 0)throw new Error("autoTruncate parameter is not supported in Gemini API.");return t}function Go(n,e){const t={},o=i(e,["fileName"]);o!=null&&s(t,["file_name"],o);const r=i(e,["inlinedRequests"]);return r!=null&&s(t,["requests"],Fo(n,r)),t}function qo(n){const e={};if(i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const t=i(n,["fileUri"]);t!=null&&s(e,["fileUri"],t);const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function Ho(n,e,t){const o={},r=i(e,["systemInstruction"]);t!==void 0&&r!=null&&s(t,["systemInstruction"],ht(L(r)));const l=i(e,["temperature"]);l!=null&&s(o,["temperature"],l);const a=i(e,["topP"]);a!=null&&s(o,["topP"],a);const u=i(e,["topK"]);u!=null&&s(o,["topK"],u);const c=i(e,["candidateCount"]);c!=null&&s(o,["candidateCount"],c);const d=i(e,["maxOutputTokens"]);d!=null&&s(o,["maxOutputTokens"],d);const f=i(e,["stopSequences"]);f!=null&&s(o,["stopSequences"],f);const p=i(e,["responseLogprobs"]);p!=null&&s(o,["responseLogprobs"],p);const h=i(e,["logprobs"]);h!=null&&s(o,["logprobs"],h);const m=i(e,["presencePenalty"]);m!=null&&s(o,["presencePenalty"],m);const g=i(e,["frequencyPenalty"]);g!=null&&s(o,["frequencyPenalty"],g);const T=i(e,["seed"]);T!=null&&s(o,["seed"],T);const C=i(e,["responseMimeType"]);C!=null&&s(o,["responseMimeType"],C);const _=i(e,["responseSchema"]);_!=null&&s(o,["responseSchema"],ve(_));const S=i(e,["responseJsonSchema"]);if(S!=null&&s(o,["responseJsonSchema"],S),i(e,["routingConfig"])!==void 0)throw new Error("routingConfig parameter is not supported in Gemini API.");if(i(e,["modelSelectionConfig"])!==void 0)throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");const E=i(e,["safetySettings"]);if(t!==void 0&&E!=null){let U=E;Array.isArray(U)&&(U=U.map(G=>ni(G))),s(t,["safetySettings"],U)}const I=i(e,["tools"]);if(t!==void 0&&I!=null){let U=X(I);Array.isArray(U)&&(U=U.map(G=>ti(O(G)))),s(t,["tools"],U)}const A=i(e,["toolConfig"]);if(t!==void 0&&A!=null&&s(t,["toolConfig"],A),i(e,["labels"])!==void 0)throw new Error("labels parameter is not supported in Gemini API.");const R=i(e,["cachedContent"]);t!==void 0&&R!=null&&s(t,["cachedContent"],J(n,R));const P=i(e,["responseModalities"]);P!=null&&s(o,["responseModalities"],P);const x=i(e,["mediaResolution"]);x!=null&&s(o,["mediaResolution"],x);const v=i(e,["speechConfig"]);if(v!=null&&s(o,["speechConfig"],Ae(v)),i(e,["audioTimestamp"])!==void 0)throw new Error("audioTimestamp parameter is not supported in Gemini API.");const N=i(e,["thinkingConfig"]);N!=null&&s(o,["thinkingConfig"],N);const k=i(e,["imageConfig"]);return k!=null&&s(o,["imageConfig"],k),o}function Bo(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["candidates"]);if(o!=null){let c=o;Array.isArray(c)&&(c=c.map(d=>Ao(d))),s(e,["candidates"],c)}const r=i(n,["modelVersion"]);r!=null&&s(e,["modelVersion"],r);const l=i(n,["promptFeedback"]);l!=null&&s(e,["promptFeedback"],l);const a=i(n,["responseId"]);a!=null&&s(e,["responseId"],a);const u=i(n,["usageMetadata"]);return u!=null&&s(e,["usageMetadata"],u),e}function Jo(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],Q(n,o)),t}function bo(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],Q(n,o)),t}function Yo(n){const e={};if(i(n,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const t=i(n,["enableWidget"]);return t!=null&&s(e,["enableWidget"],t),e}function Wo(n){const e={};if(i(n,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(i(n,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const t=i(n,["timeRangeFilter"]);return t!=null&&s(e,["timeRangeFilter"],t),e}function $o(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["request","model"],M(n,o));const r=i(e,["contents"]);if(r!=null){let u=F(r);Array.isArray(u)&&(u=u.map(c=>ht(c))),s(t,["request","contents"],u)}const l=i(e,["metadata"]);l!=null&&s(t,["metadata"],l);const a=i(e,["config"]);return a!=null&&s(t,["request","generationConfig"],Ho(n,a,i(t,["request"],{}))),t}function Ko(n){const e={},t=i(n,["response"]);t!=null&&s(e,["response"],Bo(t));const o=i(n,["error"]);return o!=null&&s(e,["error"],o),e}function zo(n,e){const t={},o=i(n,["pageSize"]);e!==void 0&&o!=null&&s(e,["_query","pageSize"],o);const r=i(n,["pageToken"]);if(e!==void 0&&r!=null&&s(e,["_query","pageToken"],r),i(n,["filter"])!==void 0)throw new Error("filter parameter is not supported in Gemini API.");return t}function Oo(n,e){const t={},o=i(n,["pageSize"]);e!==void 0&&o!=null&&s(e,["_query","pageSize"],o);const r=i(n,["pageToken"]);e!==void 0&&r!=null&&s(e,["_query","pageToken"],r);const l=i(n,["filter"]);return e!==void 0&&l!=null&&s(e,["_query","filter"],l),t}function Xo(n){const e={},t=i(n,["config"]);return t!=null&&zo(t,e),e}function Qo(n){const e={},t=i(n,["config"]);return t!=null&&Oo(t,e),e}function Zo(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["operations"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>ee(a))),s(e,["batchJobs"],l)}return e}function jo(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["batchPredictionJobs"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>me(a))),s(e,["batchJobs"],l)}return e}function ei(n){const e={},t=i(n,["functionCall"]);t!=null&&s(e,["functionCall"],t);const o=i(n,["codeExecutionResult"]);o!=null&&s(e,["codeExecutionResult"],o);const r=i(n,["executableCode"]);r!=null&&s(e,["executableCode"],r);const l=i(n,["fileData"]);l!=null&&s(e,["fileData"],qo(l));const a=i(n,["functionResponse"]);a!=null&&s(e,["functionResponse"],a);const u=i(n,["inlineData"]);u!=null&&s(e,["inlineData"],So(u));const c=i(n,["text"]);c!=null&&s(e,["text"],c);const d=i(n,["thought"]);d!=null&&s(e,["thought"],d);const f=i(n,["thoughtSignature"]);f!=null&&s(e,["thoughtSignature"],f);const p=i(n,["videoMetadata"]);return p!=null&&s(e,["videoMetadata"],p),e}function ni(n){const e={},t=i(n,["category"]);if(t!=null&&s(e,["category"],t),i(n,["method"])!==void 0)throw new Error("method parameter is not supported in Gemini API.");const o=i(n,["threshold"]);return o!=null&&s(e,["threshold"],o),e}function ti(n){const e={},t=i(n,["functionDeclarations"]);if(t!=null){let f=t;Array.isArray(f)&&(f=f.map(p=>p)),s(e,["functionDeclarations"],f)}if(i(n,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const o=i(n,["googleSearchRetrieval"]);o!=null&&s(e,["googleSearchRetrieval"],o);const r=i(n,["computerUse"]);r!=null&&s(e,["computerUse"],r);const l=i(n,["fileSearch"]);l!=null&&s(e,["fileSearch"],l);const a=i(n,["codeExecution"]);if(a!=null&&s(e,["codeExecution"],a),i(n,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const u=i(n,["googleMaps"]);u!=null&&s(e,["googleMaps"],Yo(u));const c=i(n,["googleSearch"]);c!=null&&s(e,["googleSearch"],Wo(c));const d=i(n,["urlContext"]);return d!=null&&s(e,["urlContext"],d),e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var H;(function(n){n.PAGED_ITEM_BATCH_JOBS="batchJobs",n.PAGED_ITEM_MODELS="models",n.PAGED_ITEM_TUNING_JOBS="tuningJobs",n.PAGED_ITEM_FILES="files",n.PAGED_ITEM_CACHED_CONTENTS="cachedContents",n.PAGED_ITEM_FILE_SEARCH_STORES="fileSearchStores",n.PAGED_ITEM_DOCUMENTS="documents"})(H||(H={}));class Y{constructor(e,t,o,r){this.pageInternal=[],this.paramsInternal={},this.requestInternal=t,this.init(e,o,r)}init(e,t,o){var r,l;this.nameInternal=e,this.pageInternal=t[this.nameInternal]||[],this.sdkHttpResponseInternal=t==null?void 0:t.sdkHttpResponse,this.idxInternal=0;let a={config:{}};!o||Object.keys(o).length===0?a={config:{}}:typeof o=="object"?a=Object.assign({},o):a=o,a.config&&(a.config.pageToken=t.nextPageToken),this.paramsInternal=a,this.pageInternalSize=(l=(r=a.config)===null||r===void 0?void 0:r.pageSize)!==null&&l!==void 0?l:this.pageInternal.length}initNextPage(e){this.init(this.nameInternal,e,this.paramsInternal)}get page(){return this.pageInternal}get name(){return this.nameInternal}get pageSize(){return this.pageInternalSize}get sdkHttpResponse(){return this.sdkHttpResponseInternal}get params(){return this.paramsInternal}get pageLength(){return this.pageInternal.length}getItem(e){return this.pageInternal[e]}[Symbol.asyncIterator](){return{next:async()=>{if(this.idxInternal>=this.pageLength)if(this.hasNextPage())await this.nextPage();else return{value:void 0,done:!0};const e=this.getItem(this.idxInternal);return this.idxInternal+=1,{value:e,done:!1}},return:async()=>({value:void 0,done:!0})}}async nextPage(){if(!this.hasNextPage())throw new Error("No more pages to fetch.");const e=await this.requestInternal(this.params);return this.initNextPage(e),this.page}hasNextPage(){var e;return((e=this.params.config)===null||e===void 0?void 0:e.pageToken)!==void 0}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class oi extends B{constructor(e){super(),this.apiClient=e,this.create=async t=>(this.apiClient.isVertexAI()&&(t.config=this.formatDestination(t.src,t.config)),this.createInternal(t)),this.createEmbeddings=async t=>{if(console.warn("batches.createEmbeddings() is experimental and may change without notice."),this.apiClient.isVertexAI())throw new Error("Vertex AI does not support batches.createEmbeddings.");return this.createEmbeddingsInternal(t)},this.list=async(t={})=>new Y(H.PAGED_ITEM_BATCH_JOBS,o=>this.listInternal(o),await this.listInternal(t),t)}createInlinedGenerateContentRequest(e){const t=qn(this.apiClient,e),o=t._url,r=y("{model}:batchGenerateContent",o),u=t.batch.inputConfig.requests,c=u.requests,d=[];for(const f of c){const p=Object.assign({},f);if(p.systemInstruction){const h=p.systemInstruction;delete p.systemInstruction;const m=p.request;m.systemInstruction=h,p.request=m}d.push(p)}return u.requests=d,delete t.config,delete t._url,delete t._query,{path:r,body:t}}getGcsUri(e){if(typeof e=="string")return e.startsWith("gs://")?e:void 0;if(!Array.isArray(e)&&e.gcsUri&&e.gcsUri.length>0)return e.gcsUri[0]}getBigqueryUri(e){if(typeof e=="string")return e.startsWith("bq://")?e:void 0;if(!Array.isArray(e))return e.bigqueryUri}formatDestination(e,t){const o=t?Object.assign({},t):{},r=Date.now().toString();if(o.displayName||(o.displayName=`genaiBatchJob_${r}`),o.dest===void 0){const l=this.getGcsUri(e),a=this.getBigqueryUri(e);if(l)l.endsWith(".jsonl")?o.dest=`${l.slice(0,-6)}/dest`:o.dest=`${l}_dest_${r}`;else if(a)o.dest=`${a}_dest_${r}`;else throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.")}return o}async createInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=No(this.apiClient,e);return u=y("batchPredictionJobs",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a.then(f=>me(f))}else{const d=qn(this.apiClient,e);return u=y("{model}:batchGenerateContent",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a.then(f=>ee(f))}}async createEmbeddingsInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=Do(this.apiClient,e);return l=y("{model}:asyncBatchEmbedContent",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>ee(c))}}async get(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=bo(this.apiClient,e);return u=y("batchPredictionJobs/{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a.then(f=>me(f))}else{const d=Jo(this.apiClient,e);return u=y("batches/{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a.then(f=>ee(f))}}async cancel(e){var t,o,r,l;let a="",u={};if(this.apiClient.isVertexAI()){const c=vo(this.apiClient,e);a=y("batchPredictionJobs/{name}:cancel",c._url),u=c._query,delete c._url,delete c._query,await this.apiClient.request({path:a,queryParams:u,body:JSON.stringify(c),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal})}else{const c=Io(this.apiClient,e);a=y("batches/{name}:cancel",c._url),u=c._query,delete c._url,delete c._query,await this.apiClient.request({path:a,queryParams:u,body:JSON.stringify(c),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal})}}async listInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Qo(e);return u=y("batchPredictionJobs",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=jo(f),h=new Ln;return Object.assign(h,p),h})}else{const d=Xo(e);return u=y("batches",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Zo(f),h=new Ln;return Object.assign(h,p),h})}}async delete(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=ko(this.apiClient,e);return u=y("batchPredictionJobs/{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"DELETE",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>Lo(f))}else{const d=Uo(this.apiClient,e);return u=y("batches/{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"DELETE",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>xo(f))}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ii(n){const e={},t=i(n,["data"]);if(t!=null&&s(e,["data"],t),i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function Hn(n){const e={},t=i(n,["parts"]);if(t!=null){let r=t;Array.isArray(r)&&(r=r.map(l=>Ai(l))),s(e,["parts"],r)}const o=i(n,["role"]);return o!=null&&s(e,["role"],o),e}function si(n,e){const t={},o=i(n,["ttl"]);e!==void 0&&o!=null&&s(e,["ttl"],o);const r=i(n,["expireTime"]);e!==void 0&&r!=null&&s(e,["expireTime"],r);const l=i(n,["displayName"]);e!==void 0&&l!=null&&s(e,["displayName"],l);const a=i(n,["contents"]);if(e!==void 0&&a!=null){let f=F(a);Array.isArray(f)&&(f=f.map(p=>Hn(p))),s(e,["contents"],f)}const u=i(n,["systemInstruction"]);e!==void 0&&u!=null&&s(e,["systemInstruction"],Hn(L(u)));const c=i(n,["tools"]);if(e!==void 0&&c!=null){let f=c;Array.isArray(f)&&(f=f.map(p=>Ri(p))),s(e,["tools"],f)}const d=i(n,["toolConfig"]);if(e!==void 0&&d!=null&&s(e,["toolConfig"],d),i(n,["kmsKeyName"])!==void 0)throw new Error("kmsKeyName parameter is not supported in Gemini API.");return t}function ri(n,e){const t={},o=i(n,["ttl"]);e!==void 0&&o!=null&&s(e,["ttl"],o);const r=i(n,["expireTime"]);e!==void 0&&r!=null&&s(e,["expireTime"],r);const l=i(n,["displayName"]);e!==void 0&&l!=null&&s(e,["displayName"],l);const a=i(n,["contents"]);if(e!==void 0&&a!=null){let p=F(a);Array.isArray(p)&&(p=p.map(h=>h)),s(e,["contents"],p)}const u=i(n,["systemInstruction"]);e!==void 0&&u!=null&&s(e,["systemInstruction"],L(u));const c=i(n,["tools"]);if(e!==void 0&&c!=null){let p=c;Array.isArray(p)&&(p=p.map(h=>Pi(h))),s(e,["tools"],p)}const d=i(n,["toolConfig"]);e!==void 0&&d!=null&&s(e,["toolConfig"],d);const f=i(n,["kmsKeyName"]);return e!==void 0&&f!=null&&s(e,["encryption_spec","kmsKeyName"],f),t}function li(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["model"],tt(n,o));const r=i(e,["config"]);return r!=null&&si(r,t),t}function ai(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["model"],tt(n,o));const r=i(e,["config"]);return r!=null&&ri(r,t),t}function ui(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],J(n,o)),t}function di(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],J(n,o)),t}function ci(n){const e={},t=i(n,["sdkHttpResponse"]);return t!=null&&s(e,["sdkHttpResponse"],t),e}function fi(n){const e={},t=i(n,["sdkHttpResponse"]);return t!=null&&s(e,["sdkHttpResponse"],t),e}function pi(n){const e={};if(i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const t=i(n,["fileUri"]);t!=null&&s(e,["fileUri"],t);const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function hi(n){const e={};if(i(n,["behavior"])!==void 0)throw new Error("behavior parameter is not supported in Vertex AI.");const t=i(n,["description"]);t!=null&&s(e,["description"],t);const o=i(n,["name"]);o!=null&&s(e,["name"],o);const r=i(n,["parameters"]);r!=null&&s(e,["parameters"],r);const l=i(n,["parametersJsonSchema"]);l!=null&&s(e,["parametersJsonSchema"],l);const a=i(n,["response"]);a!=null&&s(e,["response"],a);const u=i(n,["responseJsonSchema"]);return u!=null&&s(e,["responseJsonSchema"],u),e}function mi(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],J(n,o)),t}function gi(n,e){const t={},o=i(e,["name"]);return o!=null&&s(t,["_url","name"],J(n,o)),t}function Ti(n){const e={};if(i(n,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const t=i(n,["enableWidget"]);return t!=null&&s(e,["enableWidget"],t),e}function yi(n){const e={};if(i(n,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(i(n,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const t=i(n,["timeRangeFilter"]);return t!=null&&s(e,["timeRangeFilter"],t),e}function Ei(n,e){const t={},o=i(n,["pageSize"]);e!==void 0&&o!=null&&s(e,["_query","pageSize"],o);const r=i(n,["pageToken"]);return e!==void 0&&r!=null&&s(e,["_query","pageToken"],r),t}function Ci(n,e){const t={},o=i(n,["pageSize"]);e!==void 0&&o!=null&&s(e,["_query","pageSize"],o);const r=i(n,["pageToken"]);return e!==void 0&&r!=null&&s(e,["_query","pageToken"],r),t}function _i(n){const e={},t=i(n,["config"]);return t!=null&&Ei(t,e),e}function Si(n){const e={},t=i(n,["config"]);return t!=null&&Ci(t,e),e}function Ii(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["cachedContents"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>a)),s(e,["cachedContents"],l)}return e}function vi(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["cachedContents"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>a)),s(e,["cachedContents"],l)}return e}function Ai(n){const e={},t=i(n,["functionCall"]);t!=null&&s(e,["functionCall"],t);const o=i(n,["codeExecutionResult"]);o!=null&&s(e,["codeExecutionResult"],o);const r=i(n,["executableCode"]);r!=null&&s(e,["executableCode"],r);const l=i(n,["fileData"]);l!=null&&s(e,["fileData"],pi(l));const a=i(n,["functionResponse"]);a!=null&&s(e,["functionResponse"],a);const u=i(n,["inlineData"]);u!=null&&s(e,["inlineData"],ii(u));const c=i(n,["text"]);c!=null&&s(e,["text"],c);const d=i(n,["thought"]);d!=null&&s(e,["thought"],d);const f=i(n,["thoughtSignature"]);f!=null&&s(e,["thoughtSignature"],f);const p=i(n,["videoMetadata"]);return p!=null&&s(e,["videoMetadata"],p),e}function Ri(n){const e={},t=i(n,["functionDeclarations"]);if(t!=null){let f=t;Array.isArray(f)&&(f=f.map(p=>p)),s(e,["functionDeclarations"],f)}if(i(n,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const o=i(n,["googleSearchRetrieval"]);o!=null&&s(e,["googleSearchRetrieval"],o);const r=i(n,["computerUse"]);r!=null&&s(e,["computerUse"],r);const l=i(n,["fileSearch"]);l!=null&&s(e,["fileSearch"],l);const a=i(n,["codeExecution"]);if(a!=null&&s(e,["codeExecution"],a),i(n,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const u=i(n,["googleMaps"]);u!=null&&s(e,["googleMaps"],Ti(u));const c=i(n,["googleSearch"]);c!=null&&s(e,["googleSearch"],yi(c));const d=i(n,["urlContext"]);return d!=null&&s(e,["urlContext"],d),e}function Pi(n){const e={},t=i(n,["functionDeclarations"]);if(t!=null){let p=t;Array.isArray(p)&&(p=p.map(h=>hi(h))),s(e,["functionDeclarations"],p)}const o=i(n,["retrieval"]);o!=null&&s(e,["retrieval"],o);const r=i(n,["googleSearchRetrieval"]);r!=null&&s(e,["googleSearchRetrieval"],r);const l=i(n,["computerUse"]);if(l!=null&&s(e,["computerUse"],l),i(n,["fileSearch"])!==void 0)throw new Error("fileSearch parameter is not supported in Vertex AI.");const a=i(n,["codeExecution"]);a!=null&&s(e,["codeExecution"],a);const u=i(n,["enterpriseWebSearch"]);u!=null&&s(e,["enterpriseWebSearch"],u);const c=i(n,["googleMaps"]);c!=null&&s(e,["googleMaps"],c);const d=i(n,["googleSearch"]);d!=null&&s(e,["googleSearch"],d);const f=i(n,["urlContext"]);return f!=null&&s(e,["urlContext"],f),e}function Mi(n,e){const t={},o=i(n,["ttl"]);e!==void 0&&o!=null&&s(e,["ttl"],o);const r=i(n,["expireTime"]);return e!==void 0&&r!=null&&s(e,["expireTime"],r),t}function Ni(n,e){const t={},o=i(n,["ttl"]);e!==void 0&&o!=null&&s(e,["ttl"],o);const r=i(n,["expireTime"]);return e!==void 0&&r!=null&&s(e,["expireTime"],r),t}function wi(n,e){const t={},o=i(e,["name"]);o!=null&&s(t,["_url","name"],J(n,o));const r=i(e,["config"]);return r!=null&&Mi(r,t),t}function Di(n,e){const t={},o=i(e,["name"]);o!=null&&s(t,["_url","name"],J(n,o));const r=i(e,["config"]);return r!=null&&Ni(r,t),t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Ui extends B{constructor(e){super(),this.apiClient=e,this.list=async(t={})=>new Y(H.PAGED_ITEM_CACHED_CONTENTS,o=>this.listInternal(o),await this.listInternal(t),t)}async create(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=ai(this.apiClient,e);return u=y("cachedContents",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a.then(f=>f)}else{const d=li(this.apiClient,e);return u=y("cachedContents",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a.then(f=>f)}}async get(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=gi(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a.then(f=>f)}else{const d=mi(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a.then(f=>f)}}async delete(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=di(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"DELETE",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=fi(f),h=new kn;return Object.assign(h,p),h})}else{const d=ui(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"DELETE",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=ci(f),h=new kn;return Object.assign(h,p),h})}}async update(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Di(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"PATCH",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a.then(f=>f)}else{const d=wi(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"PATCH",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a.then(f=>f)}}async listInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Si(e);return u=y("cachedContents",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=vi(f),h=new xn;return Object.assign(h,p),h})}else{const d=_i(e);return u=y("cachedContents",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Ii(f),h=new xn;return Object.assign(h,p),h})}}}function Bn(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],o=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&o>=n.length&&(n=void 0),{value:n&&n[o++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function w(n){return this instanceof w?(this.v=n,this):new w(n)}function K(n,e,t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var o=t.apply(n,e||[]),r,l=[];return r=Object.create((typeof AsyncIterator=="function"?AsyncIterator:Object).prototype),u("next"),u("throw"),u("return",a),r[Symbol.asyncIterator]=function(){return this},r;function a(m){return function(g){return Promise.resolve(g).then(m,p)}}function u(m,g){o[m]&&(r[m]=function(T){return new Promise(function(C,_){l.push([m,T,C,_])>1||c(m,T)})},g&&(r[m]=g(r[m])))}function c(m,g){try{d(o[m](g))}catch(T){h(l[0][3],T)}}function d(m){m.value instanceof w?Promise.resolve(m.value.v).then(f,p):h(l[0][2],m)}function f(m){c("next",m)}function p(m){c("throw",m)}function h(m,g){m(g),l.shift(),l.length&&c(l[0][0],l[0][1])}}function j(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e=n[Symbol.asyncIterator],t;return e?e.call(n):(n=typeof Bn=="function"?Bn(n):n[Symbol.iterator](),t={},o("next"),o("throw"),o("return"),t[Symbol.asyncIterator]=function(){return this},t);function o(l){t[l]=n[l]&&function(a){return new Promise(function(u,c){a=n[l](a),r(u,c,a.done,a.value)})}}function r(l,a,u,c){Promise.resolve(c).then(function(d){l({value:d,done:u})},a)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ki(n){var e;if(n.candidates==null||n.candidates.length===0)return!1;const t=(e=n.candidates[0])===null||e===void 0?void 0:e.content;return t===void 0?!1:mt(t)}function mt(n){if(n.parts===void 0||n.parts.length===0)return!1;for(const e of n.parts)if(e===void 0||Object.keys(e).length===0)return!1;return!0}function xi(n){if(n.length!==0){for(const e of n)if(e.role!=="user"&&e.role!=="model")throw new Error(`Role must be user or model, but got ${e.role}.`)}}function Jn(n){if(n===void 0||n.length===0)return[];const e=[],t=n.length;let o=0;for(;o<t;)if(n[o].role==="user")e.push(n[o]),o++;else{const r=[];let l=!0;for(;o<t&&n[o].role==="model";)r.push(n[o]),l&&!mt(n[o])&&(l=!1),o++;l?e.push(...r):e.pop()}return e}class Li{constructor(e,t){this.modelsModule=e,this.apiClient=t}create(e){return new Fi(this.apiClient,this.modelsModule,e.model,e.config,structuredClone(e.history))}}class Fi{constructor(e,t,o,r={},l=[]){this.apiClient=e,this.modelsModule=t,this.model=o,this.config=r,this.history=l,this.sendPromise=Promise.resolve(),xi(l)}async sendMessage(e){var t;await this.sendPromise;const o=L(e.message),r=this.modelsModule.generateContent({model:this.model,contents:this.getHistory(!0).concat(o),config:(t=e.config)!==null&&t!==void 0?t:this.config});return this.sendPromise=(async()=>{var l,a,u;const c=await r,d=(a=(l=c.candidates)===null||l===void 0?void 0:l[0])===null||a===void 0?void 0:a.content,f=c.automaticFunctionCallingHistory,p=this.getHistory(!0).length;let h=[];f!=null&&(h=(u=f.slice(p))!==null&&u!==void 0?u:[]);const m=d?[d]:[];this.recordHistory(o,m,h)})(),await this.sendPromise.catch(()=>{this.sendPromise=Promise.resolve()}),r}async sendMessageStream(e){var t;await this.sendPromise;const o=L(e.message),r=this.modelsModule.generateContentStream({model:this.model,contents:this.getHistory(!0).concat(o),config:(t=e.config)!==null&&t!==void 0?t:this.config});this.sendPromise=r.then(()=>{}).catch(()=>{});const l=await r;return this.processStreamResponse(l,o)}getHistory(e=!1){const t=e?Jn(this.history):this.history;return structuredClone(t)}processStreamResponse(e,t){var o,r;return K(this,arguments,function*(){var a,u,c,d;const f=[];try{for(var p=!0,h=j(e),m;m=yield w(h.next()),a=m.done,!a;p=!0){d=m.value,p=!1;const g=d;if(ki(g)){const T=(r=(o=g.candidates)===null||o===void 0?void 0:o[0])===null||r===void 0?void 0:r.content;T!==void 0&&f.push(T)}yield yield w(g)}}catch(g){u={error:g}}finally{try{!p&&!a&&(c=h.return)&&(yield w(c.call(h)))}finally{if(u)throw u.error}}this.recordHistory(t,f)})}recordHistory(e,t,o){let r=[];t.length>0&&t.every(l=>l.role!==void 0)?r=t:r.push({role:"model",parts:[]}),o&&o.length>0?this.history.push(...Jn(o)):this.history.push(e),this.history.push(...r)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class re extends Error{constructor(e){super(e.message),this.name="ApiError",this.status=e.status,Object.setPrototypeOf(this,re.prototype)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Vi(n){const e={},t=i(n,["file"]);return t!=null&&s(e,["file"],t),e}function Gi(n){const e={},t=i(n,["sdkHttpResponse"]);return t!=null&&s(e,["sdkHttpResponse"],t),e}function qi(n){const e={},t=i(n,["name"]);return t!=null&&s(e,["_url","file"],at(t)),e}function Hi(n){const e={},t=i(n,["sdkHttpResponse"]);return t!=null&&s(e,["sdkHttpResponse"],t),e}function Bi(n){const e={},t=i(n,["name"]);return t!=null&&s(e,["_url","file"],at(t)),e}function Ji(n,e){const t={},o=i(n,["pageSize"]);e!==void 0&&o!=null&&s(e,["_query","pageSize"],o);const r=i(n,["pageToken"]);return e!==void 0&&r!=null&&s(e,["_query","pageToken"],r),t}function bi(n){const e={},t=i(n,["config"]);return t!=null&&Ji(t,e),e}function Yi(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["files"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>a)),s(e,["files"],l)}return e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Wi extends B{constructor(e){super(),this.apiClient=e,this.list=async(t={})=>new Y(H.PAGED_ITEM_FILES,o=>this.listInternal(o),await this.listInternal(t),t)}async upload(e){if(this.apiClient.isVertexAI())throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");return this.apiClient.uploadFile(e.file,e.config).then(t=>t)}async download(e){await this.apiClient.downloadFile(e)}async listInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=bi(e);return l=y("files",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json().then(d=>{const f=d;return f.sdkHttpResponse={headers:c.headers},f})),r.then(c=>{const d=Yi(c),f=new no;return Object.assign(f,d),f})}}async createInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=Vi(e);return l=y("upload/v1beta/files",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>{const d=Gi(c),f=new to;return Object.assign(f,d),f})}}async get(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=Bi(e);return l=y("files/{file}",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>c)}}async delete(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=qi(e);return l=y("files/{file}",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"DELETE",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json().then(d=>{const f=d;return f.sdkHttpResponse={headers:c.headers},f})),r.then(c=>{const d=Hi(c),f=new oo;return Object.assign(f,d),f})}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ne(n){const e={},t=i(n,["data"]);if(t!=null&&s(e,["data"],t),i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function $i(n){const e={},t=i(n,["parts"]);if(t!=null){let r=t;Array.isArray(r)&&(r=r.map(l=>ls(l))),s(e,["parts"],r)}const o=i(n,["role"]);return o!=null&&s(e,["role"],o),e}function Ki(n){const e={};if(i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const t=i(n,["fileUri"]);t!=null&&s(e,["fileUri"],t);const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function zi(n){const e={};if(i(n,["behavior"])!==void 0)throw new Error("behavior parameter is not supported in Vertex AI.");const t=i(n,["description"]);t!=null&&s(e,["description"],t);const o=i(n,["name"]);o!=null&&s(e,["name"],o);const r=i(n,["parameters"]);r!=null&&s(e,["parameters"],r);const l=i(n,["parametersJsonSchema"]);l!=null&&s(e,["parametersJsonSchema"],l);const a=i(n,["response"]);a!=null&&s(e,["response"],a);const u=i(n,["responseJsonSchema"]);return u!=null&&s(e,["responseJsonSchema"],u),e}function Oi(n){const e={},t=i(n,["modelSelectionConfig"]);t!=null&&s(e,["modelConfig"],t);const o=i(n,["responseJsonSchema"]);o!=null&&s(e,["responseJsonSchema"],o);const r=i(n,["audioTimestamp"]);r!=null&&s(e,["audioTimestamp"],r);const l=i(n,["candidateCount"]);l!=null&&s(e,["candidateCount"],l);const a=i(n,["enableAffectiveDialog"]);a!=null&&s(e,["enableAffectiveDialog"],a);const u=i(n,["frequencyPenalty"]);u!=null&&s(e,["frequencyPenalty"],u);const c=i(n,["logprobs"]);c!=null&&s(e,["logprobs"],c);const d=i(n,["maxOutputTokens"]);d!=null&&s(e,["maxOutputTokens"],d);const f=i(n,["mediaResolution"]);f!=null&&s(e,["mediaResolution"],f);const p=i(n,["presencePenalty"]);p!=null&&s(e,["presencePenalty"],p);const h=i(n,["responseLogprobs"]);h!=null&&s(e,["responseLogprobs"],h);const m=i(n,["responseMimeType"]);m!=null&&s(e,["responseMimeType"],m);const g=i(n,["responseModalities"]);g!=null&&s(e,["responseModalities"],g);const T=i(n,["responseSchema"]);T!=null&&s(e,["responseSchema"],T);const C=i(n,["routingConfig"]);C!=null&&s(e,["routingConfig"],C);const _=i(n,["seed"]);_!=null&&s(e,["seed"],_);const S=i(n,["speechConfig"]);S!=null&&s(e,["speechConfig"],gt(S));const E=i(n,["stopSequences"]);E!=null&&s(e,["stopSequences"],E);const I=i(n,["temperature"]);I!=null&&s(e,["temperature"],I);const A=i(n,["thinkingConfig"]);A!=null&&s(e,["thinkingConfig"],A);const R=i(n,["topK"]);R!=null&&s(e,["topK"],R);const P=i(n,["topP"]);if(P!=null&&s(e,["topP"],P),i(n,["enableEnhancedCivicAnswers"])!==void 0)throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");return e}function Xi(n){const e={};if(i(n,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const t=i(n,["enableWidget"]);return t!=null&&s(e,["enableWidget"],t),e}function Qi(n){const e={};if(i(n,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(i(n,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const t=i(n,["timeRangeFilter"]);return t!=null&&s(e,["timeRangeFilter"],t),e}function Zi(n,e){const t={},o=i(n,["generationConfig"]);e!==void 0&&o!=null&&s(e,["setup","generationConfig"],o);const r=i(n,["responseModalities"]);e!==void 0&&r!=null&&s(e,["setup","generationConfig","responseModalities"],r);const l=i(n,["temperature"]);e!==void 0&&l!=null&&s(e,["setup","generationConfig","temperature"],l);const a=i(n,["topP"]);e!==void 0&&a!=null&&s(e,["setup","generationConfig","topP"],a);const u=i(n,["topK"]);e!==void 0&&u!=null&&s(e,["setup","generationConfig","topK"],u);const c=i(n,["maxOutputTokens"]);e!==void 0&&c!=null&&s(e,["setup","generationConfig","maxOutputTokens"],c);const d=i(n,["mediaResolution"]);e!==void 0&&d!=null&&s(e,["setup","generationConfig","mediaResolution"],d);const f=i(n,["seed"]);e!==void 0&&f!=null&&s(e,["setup","generationConfig","seed"],f);const p=i(n,["speechConfig"]);e!==void 0&&p!=null&&s(e,["setup","generationConfig","speechConfig"],Re(p));const h=i(n,["thinkingConfig"]);e!==void 0&&h!=null&&s(e,["setup","generationConfig","thinkingConfig"],h);const m=i(n,["enableAffectiveDialog"]);e!==void 0&&m!=null&&s(e,["setup","generationConfig","enableAffectiveDialog"],m);const g=i(n,["systemInstruction"]);e!==void 0&&g!=null&&s(e,["setup","systemInstruction"],$i(L(g)));const T=i(n,["tools"]);if(e!==void 0&&T!=null){let R=X(T);Array.isArray(R)&&(R=R.map(P=>us(O(P)))),s(e,["setup","tools"],R)}const C=i(n,["sessionResumption"]);e!==void 0&&C!=null&&s(e,["setup","sessionResumption"],as(C));const _=i(n,["inputAudioTranscription"]);e!==void 0&&_!=null&&s(e,["setup","inputAudioTranscription"],_);const S=i(n,["outputAudioTranscription"]);e!==void 0&&S!=null&&s(e,["setup","outputAudioTranscription"],S);const E=i(n,["realtimeInputConfig"]);e!==void 0&&E!=null&&s(e,["setup","realtimeInputConfig"],E);const I=i(n,["contextWindowCompression"]);e!==void 0&&I!=null&&s(e,["setup","contextWindowCompression"],I);const A=i(n,["proactivity"]);return e!==void 0&&A!=null&&s(e,["setup","proactivity"],A),t}function ji(n,e){const t={},o=i(n,["generationConfig"]);e!==void 0&&o!=null&&s(e,["setup","generationConfig"],Oi(o));const r=i(n,["responseModalities"]);e!==void 0&&r!=null&&s(e,["setup","generationConfig","responseModalities"],r);const l=i(n,["temperature"]);e!==void 0&&l!=null&&s(e,["setup","generationConfig","temperature"],l);const a=i(n,["topP"]);e!==void 0&&a!=null&&s(e,["setup","generationConfig","topP"],a);const u=i(n,["topK"]);e!==void 0&&u!=null&&s(e,["setup","generationConfig","topK"],u);const c=i(n,["maxOutputTokens"]);e!==void 0&&c!=null&&s(e,["setup","generationConfig","maxOutputTokens"],c);const d=i(n,["mediaResolution"]);e!==void 0&&d!=null&&s(e,["setup","generationConfig","mediaResolution"],d);const f=i(n,["seed"]);e!==void 0&&f!=null&&s(e,["setup","generationConfig","seed"],f);const p=i(n,["speechConfig"]);e!==void 0&&p!=null&&s(e,["setup","generationConfig","speechConfig"],gt(Re(p)));const h=i(n,["thinkingConfig"]);e!==void 0&&h!=null&&s(e,["setup","generationConfig","thinkingConfig"],h);const m=i(n,["enableAffectiveDialog"]);e!==void 0&&m!=null&&s(e,["setup","generationConfig","enableAffectiveDialog"],m);const g=i(n,["systemInstruction"]);e!==void 0&&g!=null&&s(e,["setup","systemInstruction"],L(g));const T=i(n,["tools"]);if(e!==void 0&&T!=null){let R=X(T);Array.isArray(R)&&(R=R.map(P=>ds(O(P)))),s(e,["setup","tools"],R)}const C=i(n,["sessionResumption"]);e!==void 0&&C!=null&&s(e,["setup","sessionResumption"],C);const _=i(n,["inputAudioTranscription"]);e!==void 0&&_!=null&&s(e,["setup","inputAudioTranscription"],_);const S=i(n,["outputAudioTranscription"]);e!==void 0&&S!=null&&s(e,["setup","outputAudioTranscription"],S);const E=i(n,["realtimeInputConfig"]);e!==void 0&&E!=null&&s(e,["setup","realtimeInputConfig"],E);const I=i(n,["contextWindowCompression"]);e!==void 0&&I!=null&&s(e,["setup","contextWindowCompression"],I);const A=i(n,["proactivity"]);return e!==void 0&&A!=null&&s(e,["setup","proactivity"],A),t}function es(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["setup","model"],M(n,o));const r=i(e,["config"]);return r!=null&&s(t,["config"],Zi(r,t)),t}function ns(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["setup","model"],M(n,o));const r=i(e,["config"]);return r!=null&&s(t,["config"],ji(r,t)),t}function ts(n){const e={},t=i(n,["musicGenerationConfig"]);return t!=null&&s(e,["musicGenerationConfig"],t),e}function os(n){const e={},t=i(n,["weightedPrompts"]);if(t!=null){let o=t;Array.isArray(o)&&(o=o.map(r=>r)),s(e,["weightedPrompts"],o)}return e}function is(n){const e={},t=i(n,["media"]);if(t!=null){let d=ot(t);Array.isArray(d)&&(d=d.map(f=>ne(f))),s(e,["mediaChunks"],d)}const o=i(n,["audio"]);o!=null&&s(e,["audio"],ne(st(o)));const r=i(n,["audioStreamEnd"]);r!=null&&s(e,["audioStreamEnd"],r);const l=i(n,["video"]);l!=null&&s(e,["video"],ne(it(l)));const a=i(n,["text"]);a!=null&&s(e,["text"],a);const u=i(n,["activityStart"]);u!=null&&s(e,["activityStart"],u);const c=i(n,["activityEnd"]);return c!=null&&s(e,["activityEnd"],c),e}function ss(n){const e={},t=i(n,["media"]);if(t!=null){let d=ot(t);Array.isArray(d)&&(d=d.map(f=>f)),s(e,["mediaChunks"],d)}const o=i(n,["audio"]);o!=null&&s(e,["audio"],st(o));const r=i(n,["audioStreamEnd"]);r!=null&&s(e,["audioStreamEnd"],r);const l=i(n,["video"]);l!=null&&s(e,["video"],it(l));const a=i(n,["text"]);a!=null&&s(e,["text"],a);const u=i(n,["activityStart"]);u!=null&&s(e,["activityStart"],u);const c=i(n,["activityEnd"]);return c!=null&&s(e,["activityEnd"],c),e}function rs(n){const e={},t=i(n,["setupComplete"]);t!=null&&s(e,["setupComplete"],t);const o=i(n,["serverContent"]);o!=null&&s(e,["serverContent"],o);const r=i(n,["toolCall"]);r!=null&&s(e,["toolCall"],r);const l=i(n,["toolCallCancellation"]);l!=null&&s(e,["toolCallCancellation"],l);const a=i(n,["usageMetadata"]);a!=null&&s(e,["usageMetadata"],cs(a));const u=i(n,["goAway"]);u!=null&&s(e,["goAway"],u);const c=i(n,["sessionResumptionUpdate"]);return c!=null&&s(e,["sessionResumptionUpdate"],c),e}function ls(n){const e={},t=i(n,["functionCall"]);t!=null&&s(e,["functionCall"],t);const o=i(n,["codeExecutionResult"]);o!=null&&s(e,["codeExecutionResult"],o);const r=i(n,["executableCode"]);r!=null&&s(e,["executableCode"],r);const l=i(n,["fileData"]);l!=null&&s(e,["fileData"],Ki(l));const a=i(n,["functionResponse"]);a!=null&&s(e,["functionResponse"],a);const u=i(n,["inlineData"]);u!=null&&s(e,["inlineData"],ne(u));const c=i(n,["text"]);c!=null&&s(e,["text"],c);const d=i(n,["thought"]);d!=null&&s(e,["thought"],d);const f=i(n,["thoughtSignature"]);f!=null&&s(e,["thoughtSignature"],f);const p=i(n,["videoMetadata"]);return p!=null&&s(e,["videoMetadata"],p),e}function as(n){const e={},t=i(n,["handle"]);if(t!=null&&s(e,["handle"],t),i(n,["transparent"])!==void 0)throw new Error("transparent parameter is not supported in Gemini API.");return e}function gt(n){const e={},t=i(n,["languageCode"]);t!=null&&s(e,["languageCode"],t);const o=i(n,["voiceConfig"]);if(o!=null&&s(e,["voiceConfig"],o),i(n,["multiSpeakerVoiceConfig"])!==void 0)throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");return e}function us(n){const e={},t=i(n,["functionDeclarations"]);if(t!=null){let f=t;Array.isArray(f)&&(f=f.map(p=>p)),s(e,["functionDeclarations"],f)}if(i(n,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const o=i(n,["googleSearchRetrieval"]);o!=null&&s(e,["googleSearchRetrieval"],o);const r=i(n,["computerUse"]);r!=null&&s(e,["computerUse"],r);const l=i(n,["fileSearch"]);l!=null&&s(e,["fileSearch"],l);const a=i(n,["codeExecution"]);if(a!=null&&s(e,["codeExecution"],a),i(n,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const u=i(n,["googleMaps"]);u!=null&&s(e,["googleMaps"],Xi(u));const c=i(n,["googleSearch"]);c!=null&&s(e,["googleSearch"],Qi(c));const d=i(n,["urlContext"]);return d!=null&&s(e,["urlContext"],d),e}function ds(n){const e={},t=i(n,["functionDeclarations"]);if(t!=null){let p=t;Array.isArray(p)&&(p=p.map(h=>zi(h))),s(e,["functionDeclarations"],p)}const o=i(n,["retrieval"]);o!=null&&s(e,["retrieval"],o);const r=i(n,["googleSearchRetrieval"]);r!=null&&s(e,["googleSearchRetrieval"],r);const l=i(n,["computerUse"]);if(l!=null&&s(e,["computerUse"],l),i(n,["fileSearch"])!==void 0)throw new Error("fileSearch parameter is not supported in Vertex AI.");const a=i(n,["codeExecution"]);a!=null&&s(e,["codeExecution"],a);const u=i(n,["enterpriseWebSearch"]);u!=null&&s(e,["enterpriseWebSearch"],u);const c=i(n,["googleMaps"]);c!=null&&s(e,["googleMaps"],c);const d=i(n,["googleSearch"]);d!=null&&s(e,["googleSearch"],d);const f=i(n,["urlContext"]);return f!=null&&s(e,["urlContext"],f),e}function cs(n){const e={},t=i(n,["promptTokenCount"]);t!=null&&s(e,["promptTokenCount"],t);const o=i(n,["cachedContentTokenCount"]);o!=null&&s(e,["cachedContentTokenCount"],o);const r=i(n,["candidatesTokenCount"]);r!=null&&s(e,["responseTokenCount"],r);const l=i(n,["toolUsePromptTokenCount"]);l!=null&&s(e,["toolUsePromptTokenCount"],l);const a=i(n,["thoughtsTokenCount"]);a!=null&&s(e,["thoughtsTokenCount"],a);const u=i(n,["totalTokenCount"]);u!=null&&s(e,["totalTokenCount"],u);const c=i(n,["promptTokensDetails"]);if(c!=null){let m=c;Array.isArray(m)&&(m=m.map(g=>g)),s(e,["promptTokensDetails"],m)}const d=i(n,["cacheTokensDetails"]);if(d!=null){let m=d;Array.isArray(m)&&(m=m.map(g=>g)),s(e,["cacheTokensDetails"],m)}const f=i(n,["candidatesTokensDetails"]);if(f!=null){let m=f;Array.isArray(m)&&(m=m.map(g=>g)),s(e,["responseTokensDetails"],m)}const p=i(n,["toolUsePromptTokensDetails"]);if(p!=null){let m=p;Array.isArray(m)&&(m=m.map(g=>g)),s(e,["toolUsePromptTokensDetails"],m)}const h=i(n,["trafficType"]);return h!=null&&s(e,["trafficType"],h),e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function fs(n){const e={},t=i(n,["data"]);if(t!=null&&s(e,["data"],t),i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function ps(n){const e={},t=i(n,["content"]);t!=null&&s(e,["content"],t);const o=i(n,["citationMetadata"]);o!=null&&s(e,["citationMetadata"],hs(o));const r=i(n,["tokenCount"]);r!=null&&s(e,["tokenCount"],r);const l=i(n,["finishReason"]);l!=null&&s(e,["finishReason"],l);const a=i(n,["avgLogprobs"]);a!=null&&s(e,["avgLogprobs"],a);const u=i(n,["groundingMetadata"]);u!=null&&s(e,["groundingMetadata"],u);const c=i(n,["index"]);c!=null&&s(e,["index"],c);const d=i(n,["logprobsResult"]);d!=null&&s(e,["logprobsResult"],d);const f=i(n,["safetyRatings"]);if(f!=null){let h=f;Array.isArray(h)&&(h=h.map(m=>m)),s(e,["safetyRatings"],h)}const p=i(n,["urlContextMetadata"]);return p!=null&&s(e,["urlContextMetadata"],p),e}function hs(n){const e={},t=i(n,["citationSources"]);if(t!=null){let o=t;Array.isArray(o)&&(o=o.map(r=>r)),s(e,["citations"],o)}return e}function ms(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["contents"]);if(r!=null){let l=F(r);Array.isArray(l)&&(l=l.map(a=>a)),s(t,["contents"],l)}return t}function gs(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["tokensInfo"]);if(o!=null){let r=o;Array.isArray(r)&&(r=r.map(l=>l)),s(e,["tokensInfo"],r)}return e}function Ts(n){const e={},t=i(n,["values"]);t!=null&&s(e,["values"],t);const o=i(n,["statistics"]);return o!=null&&s(e,["statistics"],ys(o)),e}function ys(n){const e={},t=i(n,["truncated"]);t!=null&&s(e,["truncated"],t);const o=i(n,["token_count"]);return o!=null&&s(e,["tokenCount"],o),e}function le(n){const e={},t=i(n,["parts"]);if(t!=null){let r=t;Array.isArray(r)&&(r=r.map(l=>Ir(l))),s(e,["parts"],r)}const o=i(n,["role"]);return o!=null&&s(e,["role"],o),e}function Es(n){const e={},t=i(n,["controlType"]);t!=null&&s(e,["controlType"],t);const o=i(n,["enableControlImageComputation"]);return o!=null&&s(e,["computeControl"],o),e}function Cs(n){const e={};if(i(n,["systemInstruction"])!==void 0)throw new Error("systemInstruction parameter is not supported in Gemini API.");if(i(n,["tools"])!==void 0)throw new Error("tools parameter is not supported in Gemini API.");if(i(n,["generationConfig"])!==void 0)throw new Error("generationConfig parameter is not supported in Gemini API.");return e}function _s(n,e){const t={},o=i(n,["systemInstruction"]);e!==void 0&&o!=null&&s(e,["systemInstruction"],L(o));const r=i(n,["tools"]);if(e!==void 0&&r!=null){let a=r;Array.isArray(a)&&(a=a.map(u=>_t(u))),s(e,["tools"],a)}const l=i(n,["generationConfig"]);return e!==void 0&&l!=null&&s(e,["generationConfig"],dr(l)),t}function Ss(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["contents"]);if(r!=null){let a=F(r);Array.isArray(a)&&(a=a.map(u=>le(u))),s(t,["contents"],a)}const l=i(e,["config"]);return l!=null&&Cs(l),t}function Is(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["contents"]);if(r!=null){let a=F(r);Array.isArray(a)&&(a=a.map(u=>u)),s(t,["contents"],a)}const l=i(e,["config"]);return l!=null&&_s(l,t),t}function vs(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["totalTokens"]);o!=null&&s(e,["totalTokens"],o);const r=i(n,["cachedContentTokenCount"]);return r!=null&&s(e,["cachedContentTokenCount"],r),e}function As(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["totalTokens"]);return o!=null&&s(e,["totalTokens"],o),e}function Rs(n,e){const t={},o=i(e,["model"]);return o!=null&&s(t,["_url","name"],M(n,o)),t}function Ps(n,e){const t={},o=i(e,["model"]);return o!=null&&s(t,["_url","name"],M(n,o)),t}function Ms(n){const e={},t=i(n,["sdkHttpResponse"]);return t!=null&&s(e,["sdkHttpResponse"],t),e}function Ns(n){const e={},t=i(n,["sdkHttpResponse"]);return t!=null&&s(e,["sdkHttpResponse"],t),e}function ws(n,e){const t={},o=i(n,["outputGcsUri"]);e!==void 0&&o!=null&&s(e,["parameters","storageUri"],o);const r=i(n,["negativePrompt"]);e!==void 0&&r!=null&&s(e,["parameters","negativePrompt"],r);const l=i(n,["numberOfImages"]);e!==void 0&&l!=null&&s(e,["parameters","sampleCount"],l);const a=i(n,["aspectRatio"]);e!==void 0&&a!=null&&s(e,["parameters","aspectRatio"],a);const u=i(n,["guidanceScale"]);e!==void 0&&u!=null&&s(e,["parameters","guidanceScale"],u);const c=i(n,["seed"]);e!==void 0&&c!=null&&s(e,["parameters","seed"],c);const d=i(n,["safetyFilterLevel"]);e!==void 0&&d!=null&&s(e,["parameters","safetySetting"],d);const f=i(n,["personGeneration"]);e!==void 0&&f!=null&&s(e,["parameters","personGeneration"],f);const p=i(n,["includeSafetyAttributes"]);e!==void 0&&p!=null&&s(e,["parameters","includeSafetyAttributes"],p);const h=i(n,["includeRaiReason"]);e!==void 0&&h!=null&&s(e,["parameters","includeRaiReason"],h);const m=i(n,["language"]);e!==void 0&&m!=null&&s(e,["parameters","language"],m);const g=i(n,["outputMimeType"]);e!==void 0&&g!=null&&s(e,["parameters","outputOptions","mimeType"],g);const T=i(n,["outputCompressionQuality"]);e!==void 0&&T!=null&&s(e,["parameters","outputOptions","compressionQuality"],T);const C=i(n,["addWatermark"]);e!==void 0&&C!=null&&s(e,["parameters","addWatermark"],C);const _=i(n,["labels"]);e!==void 0&&_!=null&&s(e,["labels"],_);const S=i(n,["editMode"]);e!==void 0&&S!=null&&s(e,["parameters","editMode"],S);const E=i(n,["baseSteps"]);return e!==void 0&&E!=null&&s(e,["parameters","editConfig","baseSteps"],E),t}function Ds(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["prompt"]);r!=null&&s(t,["instances[0]","prompt"],r);const l=i(e,["referenceImages"]);if(l!=null){let u=l;Array.isArray(u)&&(u=u.map(c=>Nr(c))),s(t,["instances[0]","referenceImages"],u)}const a=i(e,["config"]);return a!=null&&ws(a,t),t}function Us(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["predictions"]);if(o!=null){let r=o;Array.isArray(r)&&(r=r.map(l=>ae(l))),s(e,["generatedImages"],r)}return e}function ks(n,e){const t={},o=i(n,["taskType"]);e!==void 0&&o!=null&&s(e,["requests[]","taskType"],o);const r=i(n,["title"]);e!==void 0&&r!=null&&s(e,["requests[]","title"],r);const l=i(n,["outputDimensionality"]);if(e!==void 0&&l!=null&&s(e,["requests[]","outputDimensionality"],l),i(n,["mimeType"])!==void 0)throw new Error("mimeType parameter is not supported in Gemini API.");if(i(n,["autoTruncate"])!==void 0)throw new Error("autoTruncate parameter is not supported in Gemini API.");return t}function xs(n,e){const t={},o=i(n,["taskType"]);e!==void 0&&o!=null&&s(e,["instances[]","task_type"],o);const r=i(n,["title"]);e!==void 0&&r!=null&&s(e,["instances[]","title"],r);const l=i(n,["outputDimensionality"]);e!==void 0&&l!=null&&s(e,["parameters","outputDimensionality"],l);const a=i(n,["mimeType"]);e!==void 0&&a!=null&&s(e,["instances[]","mimeType"],a);const u=i(n,["autoTruncate"]);return e!==void 0&&u!=null&&s(e,["parameters","autoTruncate"],u),t}function Ls(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["contents"]);if(r!=null){let u=Ie(n,r);Array.isArray(u)&&(u=u.map(c=>c)),s(t,["requests[]","content"],u)}const l=i(e,["config"]);l!=null&&ks(l,t);const a=i(e,["model"]);return a!==void 0&&s(t,["requests[]","model"],M(n,a)),t}function Fs(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["contents"]);if(r!=null){let a=Ie(n,r);Array.isArray(a)&&(a=a.map(u=>u)),s(t,["instances[]","content"],a)}const l=i(e,["config"]);return l!=null&&xs(l,t),t}function Vs(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["embeddings"]);if(o!=null){let l=o;Array.isArray(l)&&(l=l.map(a=>a)),s(e,["embeddings"],l)}const r=i(n,["metadata"]);return r!=null&&s(e,["metadata"],r),e}function Gs(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["predictions[]","embeddings"]);if(o!=null){let l=o;Array.isArray(l)&&(l=l.map(a=>Ts(a))),s(e,["embeddings"],l)}const r=i(n,["metadata"]);return r!=null&&s(e,["metadata"],r),e}function qs(n){const e={},t=i(n,["endpoint"]);t!=null&&s(e,["name"],t);const o=i(n,["deployedModelId"]);return o!=null&&s(e,["deployedModelId"],o),e}function Hs(n){const e={};if(i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const t=i(n,["fileUri"]);t!=null&&s(e,["fileUri"],t);const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function Bs(n){const e={};if(i(n,["behavior"])!==void 0)throw new Error("behavior parameter is not supported in Vertex AI.");const t=i(n,["description"]);t!=null&&s(e,["description"],t);const o=i(n,["name"]);o!=null&&s(e,["name"],o);const r=i(n,["parameters"]);r!=null&&s(e,["parameters"],r);const l=i(n,["parametersJsonSchema"]);l!=null&&s(e,["parametersJsonSchema"],l);const a=i(n,["response"]);a!=null&&s(e,["response"],a);const u=i(n,["responseJsonSchema"]);return u!=null&&s(e,["responseJsonSchema"],u),e}function Js(n,e,t){const o={},r=i(e,["systemInstruction"]);t!==void 0&&r!=null&&s(t,["systemInstruction"],le(L(r)));const l=i(e,["temperature"]);l!=null&&s(o,["temperature"],l);const a=i(e,["topP"]);a!=null&&s(o,["topP"],a);const u=i(e,["topK"]);u!=null&&s(o,["topK"],u);const c=i(e,["candidateCount"]);c!=null&&s(o,["candidateCount"],c);const d=i(e,["maxOutputTokens"]);d!=null&&s(o,["maxOutputTokens"],d);const f=i(e,["stopSequences"]);f!=null&&s(o,["stopSequences"],f);const p=i(e,["responseLogprobs"]);p!=null&&s(o,["responseLogprobs"],p);const h=i(e,["logprobs"]);h!=null&&s(o,["logprobs"],h);const m=i(e,["presencePenalty"]);m!=null&&s(o,["presencePenalty"],m);const g=i(e,["frequencyPenalty"]);g!=null&&s(o,["frequencyPenalty"],g);const T=i(e,["seed"]);T!=null&&s(o,["seed"],T);const C=i(e,["responseMimeType"]);C!=null&&s(o,["responseMimeType"],C);const _=i(e,["responseSchema"]);_!=null&&s(o,["responseSchema"],ve(_));const S=i(e,["responseJsonSchema"]);if(S!=null&&s(o,["responseJsonSchema"],S),i(e,["routingConfig"])!==void 0)throw new Error("routingConfig parameter is not supported in Gemini API.");if(i(e,["modelSelectionConfig"])!==void 0)throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");const E=i(e,["safetySettings"]);if(t!==void 0&&E!=null){let U=E;Array.isArray(U)&&(U=U.map(G=>wr(G))),s(t,["safetySettings"],U)}const I=i(e,["tools"]);if(t!==void 0&&I!=null){let U=X(I);Array.isArray(U)&&(U=U.map(G=>Fr(O(G)))),s(t,["tools"],U)}const A=i(e,["toolConfig"]);if(t!==void 0&&A!=null&&s(t,["toolConfig"],A),i(e,["labels"])!==void 0)throw new Error("labels parameter is not supported in Gemini API.");const R=i(e,["cachedContent"]);t!==void 0&&R!=null&&s(t,["cachedContent"],J(n,R));const P=i(e,["responseModalities"]);P!=null&&s(o,["responseModalities"],P);const x=i(e,["mediaResolution"]);x!=null&&s(o,["mediaResolution"],x);const v=i(e,["speechConfig"]);if(v!=null&&s(o,["speechConfig"],Ae(v)),i(e,["audioTimestamp"])!==void 0)throw new Error("audioTimestamp parameter is not supported in Gemini API.");const N=i(e,["thinkingConfig"]);N!=null&&s(o,["thinkingConfig"],N);const k=i(e,["imageConfig"]);return k!=null&&s(o,["imageConfig"],k),o}function bs(n,e,t){const o={},r=i(e,["systemInstruction"]);t!==void 0&&r!=null&&s(t,["systemInstruction"],L(r));const l=i(e,["temperature"]);l!=null&&s(o,["temperature"],l);const a=i(e,["topP"]);a!=null&&s(o,["topP"],a);const u=i(e,["topK"]);u!=null&&s(o,["topK"],u);const c=i(e,["candidateCount"]);c!=null&&s(o,["candidateCount"],c);const d=i(e,["maxOutputTokens"]);d!=null&&s(o,["maxOutputTokens"],d);const f=i(e,["stopSequences"]);f!=null&&s(o,["stopSequences"],f);const p=i(e,["responseLogprobs"]);p!=null&&s(o,["responseLogprobs"],p);const h=i(e,["logprobs"]);h!=null&&s(o,["logprobs"],h);const m=i(e,["presencePenalty"]);m!=null&&s(o,["presencePenalty"],m);const g=i(e,["frequencyPenalty"]);g!=null&&s(o,["frequencyPenalty"],g);const T=i(e,["seed"]);T!=null&&s(o,["seed"],T);const C=i(e,["responseMimeType"]);C!=null&&s(o,["responseMimeType"],C);const _=i(e,["responseSchema"]);_!=null&&s(o,["responseSchema"],ve(_));const S=i(e,["responseJsonSchema"]);S!=null&&s(o,["responseJsonSchema"],S);const E=i(e,["routingConfig"]);E!=null&&s(o,["routingConfig"],E);const I=i(e,["modelSelectionConfig"]);I!=null&&s(o,["modelConfig"],I);const A=i(e,["safetySettings"]);if(t!==void 0&&A!=null){let q=A;Array.isArray(q)&&(q=q.map(de=>de)),s(t,["safetySettings"],q)}const R=i(e,["tools"]);if(t!==void 0&&R!=null){let q=X(R);Array.isArray(q)&&(q=q.map(de=>_t(O(de)))),s(t,["tools"],q)}const P=i(e,["toolConfig"]);t!==void 0&&P!=null&&s(t,["toolConfig"],P);const x=i(e,["labels"]);t!==void 0&&x!=null&&s(t,["labels"],x);const v=i(e,["cachedContent"]);t!==void 0&&v!=null&&s(t,["cachedContent"],J(n,v));const N=i(e,["responseModalities"]);N!=null&&s(o,["responseModalities"],N);const k=i(e,["mediaResolution"]);k!=null&&s(o,["mediaResolution"],k);const U=i(e,["speechConfig"]);U!=null&&s(o,["speechConfig"],Ct(Ae(U)));const G=i(e,["audioTimestamp"]);G!=null&&s(o,["audioTimestamp"],G);const Ne=i(e,["thinkingConfig"]);Ne!=null&&s(o,["thinkingConfig"],Ne);const we=i(e,["imageConfig"]);return we!=null&&s(o,["imageConfig"],we),o}function bn(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["contents"]);if(r!=null){let a=F(r);Array.isArray(a)&&(a=a.map(u=>le(u))),s(t,["contents"],a)}const l=i(e,["config"]);return l!=null&&s(t,["generationConfig"],Js(n,l,t)),t}function Yn(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["contents"]);if(r!=null){let a=F(r);Array.isArray(a)&&(a=a.map(u=>u)),s(t,["contents"],a)}const l=i(e,["config"]);return l!=null&&s(t,["generationConfig"],bs(n,l,t)),t}function Wn(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["candidates"]);if(o!=null){let c=o;Array.isArray(c)&&(c=c.map(d=>ps(d))),s(e,["candidates"],c)}const r=i(n,["modelVersion"]);r!=null&&s(e,["modelVersion"],r);const l=i(n,["promptFeedback"]);l!=null&&s(e,["promptFeedback"],l);const a=i(n,["responseId"]);a!=null&&s(e,["responseId"],a);const u=i(n,["usageMetadata"]);return u!=null&&s(e,["usageMetadata"],u),e}function $n(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["candidates"]);if(o!=null){let d=o;Array.isArray(d)&&(d=d.map(f=>f)),s(e,["candidates"],d)}const r=i(n,["createTime"]);r!=null&&s(e,["createTime"],r);const l=i(n,["modelVersion"]);l!=null&&s(e,["modelVersion"],l);const a=i(n,["promptFeedback"]);a!=null&&s(e,["promptFeedback"],a);const u=i(n,["responseId"]);u!=null&&s(e,["responseId"],u);const c=i(n,["usageMetadata"]);return c!=null&&s(e,["usageMetadata"],c),e}function Ys(n,e){const t={};if(i(n,["outputGcsUri"])!==void 0)throw new Error("outputGcsUri parameter is not supported in Gemini API.");if(i(n,["negativePrompt"])!==void 0)throw new Error("negativePrompt parameter is not supported in Gemini API.");const o=i(n,["numberOfImages"]);e!==void 0&&o!=null&&s(e,["parameters","sampleCount"],o);const r=i(n,["aspectRatio"]);e!==void 0&&r!=null&&s(e,["parameters","aspectRatio"],r);const l=i(n,["guidanceScale"]);if(e!==void 0&&l!=null&&s(e,["parameters","guidanceScale"],l),i(n,["seed"])!==void 0)throw new Error("seed parameter is not supported in Gemini API.");const a=i(n,["safetyFilterLevel"]);e!==void 0&&a!=null&&s(e,["parameters","safetySetting"],a);const u=i(n,["personGeneration"]);e!==void 0&&u!=null&&s(e,["parameters","personGeneration"],u);const c=i(n,["includeSafetyAttributes"]);e!==void 0&&c!=null&&s(e,["parameters","includeSafetyAttributes"],c);const d=i(n,["includeRaiReason"]);e!==void 0&&d!=null&&s(e,["parameters","includeRaiReason"],d);const f=i(n,["language"]);e!==void 0&&f!=null&&s(e,["parameters","language"],f);const p=i(n,["outputMimeType"]);e!==void 0&&p!=null&&s(e,["parameters","outputOptions","mimeType"],p);const h=i(n,["outputCompressionQuality"]);if(e!==void 0&&h!=null&&s(e,["parameters","outputOptions","compressionQuality"],h),i(n,["addWatermark"])!==void 0)throw new Error("addWatermark parameter is not supported in Gemini API.");if(i(n,["labels"])!==void 0)throw new Error("labels parameter is not supported in Gemini API.");const m=i(n,["imageSize"]);if(e!==void 0&&m!=null&&s(e,["parameters","sampleImageSize"],m),i(n,["enhancePrompt"])!==void 0)throw new Error("enhancePrompt parameter is not supported in Gemini API.");return t}function Ws(n,e){const t={},o=i(n,["outputGcsUri"]);e!==void 0&&o!=null&&s(e,["parameters","storageUri"],o);const r=i(n,["negativePrompt"]);e!==void 0&&r!=null&&s(e,["parameters","negativePrompt"],r);const l=i(n,["numberOfImages"]);e!==void 0&&l!=null&&s(e,["parameters","sampleCount"],l);const a=i(n,["aspectRatio"]);e!==void 0&&a!=null&&s(e,["parameters","aspectRatio"],a);const u=i(n,["guidanceScale"]);e!==void 0&&u!=null&&s(e,["parameters","guidanceScale"],u);const c=i(n,["seed"]);e!==void 0&&c!=null&&s(e,["parameters","seed"],c);const d=i(n,["safetyFilterLevel"]);e!==void 0&&d!=null&&s(e,["parameters","safetySetting"],d);const f=i(n,["personGeneration"]);e!==void 0&&f!=null&&s(e,["parameters","personGeneration"],f);const p=i(n,["includeSafetyAttributes"]);e!==void 0&&p!=null&&s(e,["parameters","includeSafetyAttributes"],p);const h=i(n,["includeRaiReason"]);e!==void 0&&h!=null&&s(e,["parameters","includeRaiReason"],h);const m=i(n,["language"]);e!==void 0&&m!=null&&s(e,["parameters","language"],m);const g=i(n,["outputMimeType"]);e!==void 0&&g!=null&&s(e,["parameters","outputOptions","mimeType"],g);const T=i(n,["outputCompressionQuality"]);e!==void 0&&T!=null&&s(e,["parameters","outputOptions","compressionQuality"],T);const C=i(n,["addWatermark"]);e!==void 0&&C!=null&&s(e,["parameters","addWatermark"],C);const _=i(n,["labels"]);e!==void 0&&_!=null&&s(e,["labels"],_);const S=i(n,["imageSize"]);e!==void 0&&S!=null&&s(e,["parameters","sampleImageSize"],S);const E=i(n,["enhancePrompt"]);return e!==void 0&&E!=null&&s(e,["parameters","enhancePrompt"],E),t}function $s(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["prompt"]);r!=null&&s(t,["instances[0]","prompt"],r);const l=i(e,["config"]);return l!=null&&Ys(l,t),t}function Ks(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["prompt"]);r!=null&&s(t,["instances[0]","prompt"],r);const l=i(e,["config"]);return l!=null&&Ws(l,t),t}function zs(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["predictions"]);if(o!=null){let l=o;Array.isArray(l)&&(l=l.map(a=>rr(a))),s(e,["generatedImages"],l)}const r=i(n,["positivePromptSafetyAttributes"]);return r!=null&&s(e,["positivePromptSafetyAttributes"],yt(r)),e}function Os(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["predictions"]);if(o!=null){let l=o;Array.isArray(l)&&(l=l.map(a=>ae(a))),s(e,["generatedImages"],l)}const r=i(n,["positivePromptSafetyAttributes"]);return r!=null&&s(e,["positivePromptSafetyAttributes"],Et(r)),e}function Xs(n,e){const t={},o=i(n,["numberOfVideos"]);if(e!==void 0&&o!=null&&s(e,["parameters","sampleCount"],o),i(n,["outputGcsUri"])!==void 0)throw new Error("outputGcsUri parameter is not supported in Gemini API.");if(i(n,["fps"])!==void 0)throw new Error("fps parameter is not supported in Gemini API.");const r=i(n,["durationSeconds"]);if(e!==void 0&&r!=null&&s(e,["parameters","durationSeconds"],r),i(n,["seed"])!==void 0)throw new Error("seed parameter is not supported in Gemini API.");const l=i(n,["aspectRatio"]);e!==void 0&&l!=null&&s(e,["parameters","aspectRatio"],l);const a=i(n,["resolution"]);e!==void 0&&a!=null&&s(e,["parameters","resolution"],a);const u=i(n,["personGeneration"]);if(e!==void 0&&u!=null&&s(e,["parameters","personGeneration"],u),i(n,["pubsubTopic"])!==void 0)throw new Error("pubsubTopic parameter is not supported in Gemini API.");const c=i(n,["negativePrompt"]);e!==void 0&&c!=null&&s(e,["parameters","negativePrompt"],c);const d=i(n,["enhancePrompt"]);if(e!==void 0&&d!=null&&s(e,["parameters","enhancePrompt"],d),i(n,["generateAudio"])!==void 0)throw new Error("generateAudio parameter is not supported in Gemini API.");const f=i(n,["lastFrame"]);e!==void 0&&f!=null&&s(e,["instances[0]","lastFrame"],ue(f));const p=i(n,["referenceImages"]);if(e!==void 0&&p!=null){let h=p;Array.isArray(h)&&(h=h.map(m=>Or(m))),s(e,["instances[0]","referenceImages"],h)}if(i(n,["mask"])!==void 0)throw new Error("mask parameter is not supported in Gemini API.");if(i(n,["compressionQuality"])!==void 0)throw new Error("compressionQuality parameter is not supported in Gemini API.");return t}function Qs(n,e){const t={},o=i(n,["numberOfVideos"]);e!==void 0&&o!=null&&s(e,["parameters","sampleCount"],o);const r=i(n,["outputGcsUri"]);e!==void 0&&r!=null&&s(e,["parameters","storageUri"],r);const l=i(n,["fps"]);e!==void 0&&l!=null&&s(e,["parameters","fps"],l);const a=i(n,["durationSeconds"]);e!==void 0&&a!=null&&s(e,["parameters","durationSeconds"],a);const u=i(n,["seed"]);e!==void 0&&u!=null&&s(e,["parameters","seed"],u);const c=i(n,["aspectRatio"]);e!==void 0&&c!=null&&s(e,["parameters","aspectRatio"],c);const d=i(n,["resolution"]);e!==void 0&&d!=null&&s(e,["parameters","resolution"],d);const f=i(n,["personGeneration"]);e!==void 0&&f!=null&&s(e,["parameters","personGeneration"],f);const p=i(n,["pubsubTopic"]);e!==void 0&&p!=null&&s(e,["parameters","pubsubTopic"],p);const h=i(n,["negativePrompt"]);e!==void 0&&h!=null&&s(e,["parameters","negativePrompt"],h);const m=i(n,["enhancePrompt"]);e!==void 0&&m!=null&&s(e,["parameters","enhancePrompt"],m);const g=i(n,["generateAudio"]);e!==void 0&&g!=null&&s(e,["parameters","generateAudio"],g);const T=i(n,["lastFrame"]);e!==void 0&&T!=null&&s(e,["instances[0]","lastFrame"],V(T));const C=i(n,["referenceImages"]);if(e!==void 0&&C!=null){let E=C;Array.isArray(E)&&(E=E.map(I=>Xr(I))),s(e,["instances[0]","referenceImages"],E)}const _=i(n,["mask"]);e!==void 0&&_!=null&&s(e,["instances[0]","mask"],zr(_));const S=i(n,["compressionQuality"]);return e!==void 0&&S!=null&&s(e,["parameters","compressionQuality"],S),t}function Zs(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["metadata"]);o!=null&&s(e,["metadata"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);l!=null&&s(e,["error"],l);const a=i(n,["response","generateVideoResponse"]);return a!=null&&s(e,["response"],tr(a)),e}function js(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["metadata"]);o!=null&&s(e,["metadata"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);l!=null&&s(e,["error"],l);const a=i(n,["response"]);return a!=null&&s(e,["response"],or(a)),e}function er(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["prompt"]);r!=null&&s(t,["instances[0]","prompt"],r);const l=i(e,["image"]);l!=null&&s(t,["instances[0]","image"],ue(l));const a=i(e,["video"]);a!=null&&s(t,["instances[0]","video"],St(a));const u=i(e,["source"]);u!=null&&ir(u,t);const c=i(e,["config"]);return c!=null&&Xs(c,t),t}function nr(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["prompt"]);r!=null&&s(t,["instances[0]","prompt"],r);const l=i(e,["image"]);l!=null&&s(t,["instances[0]","image"],V(l));const a=i(e,["video"]);a!=null&&s(t,["instances[0]","video"],It(a));const u=i(e,["source"]);u!=null&&sr(u,t);const c=i(e,["config"]);return c!=null&&Qs(c,t),t}function tr(n){const e={},t=i(n,["generatedSamples"]);if(t!=null){let l=t;Array.isArray(l)&&(l=l.map(a=>ar(a))),s(e,["generatedVideos"],l)}const o=i(n,["raiMediaFilteredCount"]);o!=null&&s(e,["raiMediaFilteredCount"],o);const r=i(n,["raiMediaFilteredReasons"]);return r!=null&&s(e,["raiMediaFilteredReasons"],r),e}function or(n){const e={},t=i(n,["videos"]);if(t!=null){let l=t;Array.isArray(l)&&(l=l.map(a=>ur(a))),s(e,["generatedVideos"],l)}const o=i(n,["raiMediaFilteredCount"]);o!=null&&s(e,["raiMediaFilteredCount"],o);const r=i(n,["raiMediaFilteredReasons"]);return r!=null&&s(e,["raiMediaFilteredReasons"],r),e}function ir(n,e){const t={},o=i(n,["prompt"]);e!==void 0&&o!=null&&s(e,["instances[0]","prompt"],o);const r=i(n,["image"]);e!==void 0&&r!=null&&s(e,["instances[0]","image"],ue(r));const l=i(n,["video"]);return e!==void 0&&l!=null&&s(e,["instances[0]","video"],St(l)),t}function sr(n,e){const t={},o=i(n,["prompt"]);e!==void 0&&o!=null&&s(e,["instances[0]","prompt"],o);const r=i(n,["image"]);e!==void 0&&r!=null&&s(e,["instances[0]","image"],V(r));const l=i(n,["video"]);return e!==void 0&&l!=null&&s(e,["instances[0]","video"],It(l)),t}function rr(n){const e={},t=i(n,["_self"]);t!=null&&s(e,["image"],mr(t));const o=i(n,["raiFilteredReason"]);o!=null&&s(e,["raiFilteredReason"],o);const r=i(n,["_self"]);return r!=null&&s(e,["safetyAttributes"],yt(r)),e}function ae(n){const e={},t=i(n,["_self"]);t!=null&&s(e,["image"],Tt(t));const o=i(n,["raiFilteredReason"]);o!=null&&s(e,["raiFilteredReason"],o);const r=i(n,["_self"]);r!=null&&s(e,["safetyAttributes"],Et(r));const l=i(n,["prompt"]);return l!=null&&s(e,["enhancedPrompt"],l),e}function lr(n){const e={},t=i(n,["_self"]);t!=null&&s(e,["mask"],Tt(t));const o=i(n,["labels"]);if(o!=null){let r=o;Array.isArray(r)&&(r=r.map(l=>l)),s(e,["labels"],r)}return e}function ar(n){const e={},t=i(n,["video"]);return t!=null&&s(e,["video"],$r(t)),e}function ur(n){const e={},t=i(n,["_self"]);return t!=null&&s(e,["video"],Kr(t)),e}function dr(n){const e={},t=i(n,["modelSelectionConfig"]);t!=null&&s(e,["modelConfig"],t);const o=i(n,["responseJsonSchema"]);o!=null&&s(e,["responseJsonSchema"],o);const r=i(n,["audioTimestamp"]);r!=null&&s(e,["audioTimestamp"],r);const l=i(n,["candidateCount"]);l!=null&&s(e,["candidateCount"],l);const a=i(n,["enableAffectiveDialog"]);a!=null&&s(e,["enableAffectiveDialog"],a);const u=i(n,["frequencyPenalty"]);u!=null&&s(e,["frequencyPenalty"],u);const c=i(n,["logprobs"]);c!=null&&s(e,["logprobs"],c);const d=i(n,["maxOutputTokens"]);d!=null&&s(e,["maxOutputTokens"],d);const f=i(n,["mediaResolution"]);f!=null&&s(e,["mediaResolution"],f);const p=i(n,["presencePenalty"]);p!=null&&s(e,["presencePenalty"],p);const h=i(n,["responseLogprobs"]);h!=null&&s(e,["responseLogprobs"],h);const m=i(n,["responseMimeType"]);m!=null&&s(e,["responseMimeType"],m);const g=i(n,["responseModalities"]);g!=null&&s(e,["responseModalities"],g);const T=i(n,["responseSchema"]);T!=null&&s(e,["responseSchema"],T);const C=i(n,["routingConfig"]);C!=null&&s(e,["routingConfig"],C);const _=i(n,["seed"]);_!=null&&s(e,["seed"],_);const S=i(n,["speechConfig"]);S!=null&&s(e,["speechConfig"],Ct(S));const E=i(n,["stopSequences"]);E!=null&&s(e,["stopSequences"],E);const I=i(n,["temperature"]);I!=null&&s(e,["temperature"],I);const A=i(n,["thinkingConfig"]);A!=null&&s(e,["thinkingConfig"],A);const R=i(n,["topK"]);R!=null&&s(e,["topK"],R);const P=i(n,["topP"]);if(P!=null&&s(e,["topP"],P),i(n,["enableEnhancedCivicAnswers"])!==void 0)throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");return e}function cr(n,e){const t={},o=i(e,["model"]);return o!=null&&s(t,["_url","name"],M(n,o)),t}function fr(n,e){const t={},o=i(e,["model"]);return o!=null&&s(t,["_url","name"],M(n,o)),t}function pr(n){const e={};if(i(n,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const t=i(n,["enableWidget"]);return t!=null&&s(e,["enableWidget"],t),e}function hr(n){const e={};if(i(n,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(i(n,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const t=i(n,["timeRangeFilter"]);return t!=null&&s(e,["timeRangeFilter"],t),e}function mr(n){const e={},t=i(n,["bytesBase64Encoded"]);t!=null&&s(e,["imageBytes"],b(t));const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function Tt(n){const e={},t=i(n,["gcsUri"]);t!=null&&s(e,["gcsUri"],t);const o=i(n,["bytesBase64Encoded"]);o!=null&&s(e,["imageBytes"],b(o));const r=i(n,["mimeType"]);return r!=null&&s(e,["mimeType"],r),e}function ue(n){const e={};if(i(n,["gcsUri"])!==void 0)throw new Error("gcsUri parameter is not supported in Gemini API.");const t=i(n,["imageBytes"]);t!=null&&s(e,["bytesBase64Encoded"],b(t));const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function V(n){const e={},t=i(n,["gcsUri"]);t!=null&&s(e,["gcsUri"],t);const o=i(n,["imageBytes"]);o!=null&&s(e,["bytesBase64Encoded"],b(o));const r=i(n,["mimeType"]);return r!=null&&s(e,["mimeType"],r),e}function gr(n,e,t){const o={},r=i(e,["pageSize"]);t!==void 0&&r!=null&&s(t,["_query","pageSize"],r);const l=i(e,["pageToken"]);t!==void 0&&l!=null&&s(t,["_query","pageToken"],l);const a=i(e,["filter"]);t!==void 0&&a!=null&&s(t,["_query","filter"],a);const u=i(e,["queryBase"]);return t!==void 0&&u!=null&&s(t,["_url","models_url"],ut(n,u)),o}function Tr(n,e,t){const o={},r=i(e,["pageSize"]);t!==void 0&&r!=null&&s(t,["_query","pageSize"],r);const l=i(e,["pageToken"]);t!==void 0&&l!=null&&s(t,["_query","pageToken"],l);const a=i(e,["filter"]);t!==void 0&&a!=null&&s(t,["_query","filter"],a);const u=i(e,["queryBase"]);return t!==void 0&&u!=null&&s(t,["_url","models_url"],ut(n,u)),o}function yr(n,e){const t={},o=i(e,["config"]);return o!=null&&gr(n,o,t),t}function Er(n,e){const t={},o=i(e,["config"]);return o!=null&&Tr(n,o,t),t}function Cr(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["_self"]);if(r!=null){let l=dt(r);Array.isArray(l)&&(l=l.map(a=>ge(a))),s(e,["models"],l)}return e}function _r(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["_self"]);if(r!=null){let l=dt(r);Array.isArray(l)&&(l=l.map(a=>Te(a))),s(e,["models"],l)}return e}function Sr(n){const e={},t=i(n,["maskMode"]);t!=null&&s(e,["maskMode"],t);const o=i(n,["segmentationClasses"]);o!=null&&s(e,["maskClasses"],o);const r=i(n,["maskDilation"]);return r!=null&&s(e,["dilation"],r),e}function ge(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["displayName"]);o!=null&&s(e,["displayName"],o);const r=i(n,["description"]);r!=null&&s(e,["description"],r);const l=i(n,["version"]);l!=null&&s(e,["version"],l);const a=i(n,["_self"]);a!=null&&s(e,["tunedModelInfo"],Vr(a));const u=i(n,["inputTokenLimit"]);u!=null&&s(e,["inputTokenLimit"],u);const c=i(n,["outputTokenLimit"]);c!=null&&s(e,["outputTokenLimit"],c);const d=i(n,["supportedGenerationMethods"]);d!=null&&s(e,["supportedActions"],d);const f=i(n,["temperature"]);f!=null&&s(e,["temperature"],f);const p=i(n,["maxTemperature"]);p!=null&&s(e,["maxTemperature"],p);const h=i(n,["topP"]);h!=null&&s(e,["topP"],h);const m=i(n,["topK"]);m!=null&&s(e,["topK"],m);const g=i(n,["thinking"]);return g!=null&&s(e,["thinking"],g),e}function Te(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["displayName"]);o!=null&&s(e,["displayName"],o);const r=i(n,["description"]);r!=null&&s(e,["description"],r);const l=i(n,["versionId"]);l!=null&&s(e,["version"],l);const a=i(n,["deployedModels"]);if(a!=null){let p=a;Array.isArray(p)&&(p=p.map(h=>qs(h))),s(e,["endpoints"],p)}const u=i(n,["labels"]);u!=null&&s(e,["labels"],u);const c=i(n,["_self"]);c!=null&&s(e,["tunedModelInfo"],Gr(c));const d=i(n,["defaultCheckpointId"]);d!=null&&s(e,["defaultCheckpointId"],d);const f=i(n,["checkpoints"]);if(f!=null){let p=f;Array.isArray(p)&&(p=p.map(h=>h)),s(e,["checkpoints"],p)}return e}function Ir(n){const e={},t=i(n,["functionCall"]);t!=null&&s(e,["functionCall"],t);const o=i(n,["codeExecutionResult"]);o!=null&&s(e,["codeExecutionResult"],o);const r=i(n,["executableCode"]);r!=null&&s(e,["executableCode"],r);const l=i(n,["fileData"]);l!=null&&s(e,["fileData"],Hs(l));const a=i(n,["functionResponse"]);a!=null&&s(e,["functionResponse"],a);const u=i(n,["inlineData"]);u!=null&&s(e,["inlineData"],fs(u));const c=i(n,["text"]);c!=null&&s(e,["text"],c);const d=i(n,["thought"]);d!=null&&s(e,["thought"],d);const f=i(n,["thoughtSignature"]);f!=null&&s(e,["thoughtSignature"],f);const p=i(n,["videoMetadata"]);return p!=null&&s(e,["videoMetadata"],p),e}function vr(n){const e={},t=i(n,["productImage"]);return t!=null&&s(e,["image"],V(t)),e}function Ar(n,e){const t={},o=i(n,["numberOfImages"]);e!==void 0&&o!=null&&s(e,["parameters","sampleCount"],o);const r=i(n,["baseSteps"]);e!==void 0&&r!=null&&s(e,["parameters","baseSteps"],r);const l=i(n,["outputGcsUri"]);e!==void 0&&l!=null&&s(e,["parameters","storageUri"],l);const a=i(n,["seed"]);e!==void 0&&a!=null&&s(e,["parameters","seed"],a);const u=i(n,["safetyFilterLevel"]);e!==void 0&&u!=null&&s(e,["parameters","safetySetting"],u);const c=i(n,["personGeneration"]);e!==void 0&&c!=null&&s(e,["parameters","personGeneration"],c);const d=i(n,["addWatermark"]);e!==void 0&&d!=null&&s(e,["parameters","addWatermark"],d);const f=i(n,["outputMimeType"]);e!==void 0&&f!=null&&s(e,["parameters","outputOptions","mimeType"],f);const p=i(n,["outputCompressionQuality"]);e!==void 0&&p!=null&&s(e,["parameters","outputOptions","compressionQuality"],p);const h=i(n,["enhancePrompt"]);e!==void 0&&h!=null&&s(e,["parameters","enhancePrompt"],h);const m=i(n,["labels"]);return e!==void 0&&m!=null&&s(e,["labels"],m),t}function Rr(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["source"]);r!=null&&Mr(r,t);const l=i(e,["config"]);return l!=null&&Ar(l,t),t}function Pr(n){const e={},t=i(n,["predictions"]);if(t!=null){let o=t;Array.isArray(o)&&(o=o.map(r=>ae(r))),s(e,["generatedImages"],o)}return e}function Mr(n,e){const t={},o=i(n,["prompt"]);e!==void 0&&o!=null&&s(e,["instances[0]","prompt"],o);const r=i(n,["personImage"]);e!==void 0&&r!=null&&s(e,["instances[0]","personImage","image"],V(r));const l=i(n,["productImages"]);if(e!==void 0&&l!=null){let a=l;Array.isArray(a)&&(a=a.map(u=>vr(u))),s(e,["instances[0]","productImages"],a)}return t}function Nr(n){const e={},t=i(n,["referenceImage"]);t!=null&&s(e,["referenceImage"],V(t));const o=i(n,["referenceId"]);o!=null&&s(e,["referenceId"],o);const r=i(n,["referenceType"]);r!=null&&s(e,["referenceType"],r);const l=i(n,["maskImageConfig"]);l!=null&&s(e,["maskImageConfig"],Sr(l));const a=i(n,["controlImageConfig"]);a!=null&&s(e,["controlImageConfig"],Es(a));const u=i(n,["styleImageConfig"]);u!=null&&s(e,["styleImageConfig"],u);const c=i(n,["subjectImageConfig"]);return c!=null&&s(e,["subjectImageConfig"],c),e}function yt(n){const e={},t=i(n,["safetyAttributes","categories"]);t!=null&&s(e,["categories"],t);const o=i(n,["safetyAttributes","scores"]);o!=null&&s(e,["scores"],o);const r=i(n,["contentType"]);return r!=null&&s(e,["contentType"],r),e}function Et(n){const e={},t=i(n,["safetyAttributes","categories"]);t!=null&&s(e,["categories"],t);const o=i(n,["safetyAttributes","scores"]);o!=null&&s(e,["scores"],o);const r=i(n,["contentType"]);return r!=null&&s(e,["contentType"],r),e}function wr(n){const e={},t=i(n,["category"]);if(t!=null&&s(e,["category"],t),i(n,["method"])!==void 0)throw new Error("method parameter is not supported in Gemini API.");const o=i(n,["threshold"]);return o!=null&&s(e,["threshold"],o),e}function Dr(n){const e={},t=i(n,["image"]);return t!=null&&s(e,["image"],V(t)),e}function Ur(n,e){const t={},o=i(n,["mode"]);e!==void 0&&o!=null&&s(e,["parameters","mode"],o);const r=i(n,["maxPredictions"]);e!==void 0&&r!=null&&s(e,["parameters","maxPredictions"],r);const l=i(n,["confidenceThreshold"]);e!==void 0&&l!=null&&s(e,["parameters","confidenceThreshold"],l);const a=i(n,["maskDilation"]);e!==void 0&&a!=null&&s(e,["parameters","maskDilation"],a);const u=i(n,["binaryColorThreshold"]);e!==void 0&&u!=null&&s(e,["parameters","binaryColorThreshold"],u);const c=i(n,["labels"]);return e!==void 0&&c!=null&&s(e,["labels"],c),t}function kr(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["source"]);r!=null&&Lr(r,t);const l=i(e,["config"]);return l!=null&&Ur(l,t),t}function xr(n){const e={},t=i(n,["predictions"]);if(t!=null){let o=t;Array.isArray(o)&&(o=o.map(r=>lr(r))),s(e,["generatedMasks"],o)}return e}function Lr(n,e){const t={},o=i(n,["prompt"]);e!==void 0&&o!=null&&s(e,["instances[0]","prompt"],o);const r=i(n,["image"]);e!==void 0&&r!=null&&s(e,["instances[0]","image"],V(r));const l=i(n,["scribbleImage"]);return e!==void 0&&l!=null&&s(e,["instances[0]","scribble"],Dr(l)),t}function Ct(n){const e={},t=i(n,["languageCode"]);t!=null&&s(e,["languageCode"],t);const o=i(n,["voiceConfig"]);if(o!=null&&s(e,["voiceConfig"],o),i(n,["multiSpeakerVoiceConfig"])!==void 0)throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI.");return e}function Fr(n){const e={},t=i(n,["functionDeclarations"]);if(t!=null){let f=t;Array.isArray(f)&&(f=f.map(p=>p)),s(e,["functionDeclarations"],f)}if(i(n,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const o=i(n,["googleSearchRetrieval"]);o!=null&&s(e,["googleSearchRetrieval"],o);const r=i(n,["computerUse"]);r!=null&&s(e,["computerUse"],r);const l=i(n,["fileSearch"]);l!=null&&s(e,["fileSearch"],l);const a=i(n,["codeExecution"]);if(a!=null&&s(e,["codeExecution"],a),i(n,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const u=i(n,["googleMaps"]);u!=null&&s(e,["googleMaps"],pr(u));const c=i(n,["googleSearch"]);c!=null&&s(e,["googleSearch"],hr(c));const d=i(n,["urlContext"]);return d!=null&&s(e,["urlContext"],d),e}function _t(n){const e={},t=i(n,["functionDeclarations"]);if(t!=null){let p=t;Array.isArray(p)&&(p=p.map(h=>Bs(h))),s(e,["functionDeclarations"],p)}const o=i(n,["retrieval"]);o!=null&&s(e,["retrieval"],o);const r=i(n,["googleSearchRetrieval"]);r!=null&&s(e,["googleSearchRetrieval"],r);const l=i(n,["computerUse"]);if(l!=null&&s(e,["computerUse"],l),i(n,["fileSearch"])!==void 0)throw new Error("fileSearch parameter is not supported in Vertex AI.");const a=i(n,["codeExecution"]);a!=null&&s(e,["codeExecution"],a);const u=i(n,["enterpriseWebSearch"]);u!=null&&s(e,["enterpriseWebSearch"],u);const c=i(n,["googleMaps"]);c!=null&&s(e,["googleMaps"],c);const d=i(n,["googleSearch"]);d!=null&&s(e,["googleSearch"],d);const f=i(n,["urlContext"]);return f!=null&&s(e,["urlContext"],f),e}function Vr(n){const e={},t=i(n,["baseModel"]);t!=null&&s(e,["baseModel"],t);const o=i(n,["createTime"]);o!=null&&s(e,["createTime"],o);const r=i(n,["updateTime"]);return r!=null&&s(e,["updateTime"],r),e}function Gr(n){const e={},t=i(n,["labels","google-vertex-llm-tuning-base-model-id"]);t!=null&&s(e,["baseModel"],t);const o=i(n,["createTime"]);o!=null&&s(e,["createTime"],o);const r=i(n,["updateTime"]);return r!=null&&s(e,["updateTime"],r),e}function qr(n,e){const t={},o=i(n,["displayName"]);e!==void 0&&o!=null&&s(e,["displayName"],o);const r=i(n,["description"]);e!==void 0&&r!=null&&s(e,["description"],r);const l=i(n,["defaultCheckpointId"]);return e!==void 0&&l!=null&&s(e,["defaultCheckpointId"],l),t}function Hr(n,e){const t={},o=i(n,["displayName"]);e!==void 0&&o!=null&&s(e,["displayName"],o);const r=i(n,["description"]);e!==void 0&&r!=null&&s(e,["description"],r);const l=i(n,["defaultCheckpointId"]);return e!==void 0&&l!=null&&s(e,["defaultCheckpointId"],l),t}function Br(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","name"],M(n,o));const r=i(e,["config"]);return r!=null&&qr(r,t),t}function Jr(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["config"]);return r!=null&&Hr(r,t),t}function br(n,e){const t={},o=i(n,["outputGcsUri"]);e!==void 0&&o!=null&&s(e,["parameters","storageUri"],o);const r=i(n,["safetyFilterLevel"]);e!==void 0&&r!=null&&s(e,["parameters","safetySetting"],r);const l=i(n,["personGeneration"]);e!==void 0&&l!=null&&s(e,["parameters","personGeneration"],l);const a=i(n,["includeRaiReason"]);e!==void 0&&a!=null&&s(e,["parameters","includeRaiReason"],a);const u=i(n,["outputMimeType"]);e!==void 0&&u!=null&&s(e,["parameters","outputOptions","mimeType"],u);const c=i(n,["outputCompressionQuality"]);e!==void 0&&c!=null&&s(e,["parameters","outputOptions","compressionQuality"],c);const d=i(n,["enhanceInputImage"]);e!==void 0&&d!=null&&s(e,["parameters","upscaleConfig","enhanceInputImage"],d);const f=i(n,["imagePreservationFactor"]);e!==void 0&&f!=null&&s(e,["parameters","upscaleConfig","imagePreservationFactor"],f);const p=i(n,["labels"]);e!==void 0&&p!=null&&s(e,["labels"],p);const h=i(n,["numberOfImages"]);e!==void 0&&h!=null&&s(e,["parameters","sampleCount"],h);const m=i(n,["mode"]);return e!==void 0&&m!=null&&s(e,["parameters","mode"],m),t}function Yr(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["_url","model"],M(n,o));const r=i(e,["image"]);r!=null&&s(t,["instances[0]","image"],V(r));const l=i(e,["upscaleFactor"]);l!=null&&s(t,["parameters","upscaleConfig","upscaleFactor"],l);const a=i(e,["config"]);return a!=null&&br(a,t),t}function Wr(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["predictions"]);if(o!=null){let r=o;Array.isArray(r)&&(r=r.map(l=>ae(l))),s(e,["generatedImages"],r)}return e}function $r(n){const e={},t=i(n,["uri"]);t!=null&&s(e,["uri"],t);const o=i(n,["encodedVideo"]);o!=null&&s(e,["videoBytes"],b(o));const r=i(n,["encoding"]);return r!=null&&s(e,["mimeType"],r),e}function Kr(n){const e={},t=i(n,["gcsUri"]);t!=null&&s(e,["uri"],t);const o=i(n,["bytesBase64Encoded"]);o!=null&&s(e,["videoBytes"],b(o));const r=i(n,["mimeType"]);return r!=null&&s(e,["mimeType"],r),e}function zr(n){const e={},t=i(n,["image"]);t!=null&&s(e,["_self"],V(t));const o=i(n,["maskMode"]);return o!=null&&s(e,["maskMode"],o),e}function Or(n){const e={},t=i(n,["image"]);t!=null&&s(e,["image"],ue(t));const o=i(n,["referenceType"]);return o!=null&&s(e,["referenceType"],o),e}function Xr(n){const e={},t=i(n,["image"]);t!=null&&s(e,["image"],V(t));const o=i(n,["referenceType"]);return o!=null&&s(e,["referenceType"],o),e}function St(n){const e={},t=i(n,["uri"]);t!=null&&s(e,["uri"],t);const o=i(n,["videoBytes"]);o!=null&&s(e,["encodedVideo"],b(o));const r=i(n,["mimeType"]);return r!=null&&s(e,["encoding"],r),e}function It(n){const e={},t=i(n,["uri"]);t!=null&&s(e,["gcsUri"],t);const o=i(n,["videoBytes"]);o!=null&&s(e,["bytesBase64Encoded"],b(o));const r=i(n,["mimeType"]);return r!=null&&s(e,["mimeType"],r),e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Qr="Content-Type",Zr="X-Server-Timeout",jr="User-Agent",ye="x-goog-api-client",el="1.29.1",nl=`google-genai-sdk/${el}`,tl="v1beta1",ol="v1beta",Kn=/^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;class il{constructor(e){var t,o;this.clientOptions=Object.assign(Object.assign({},e),{project:e.project,location:e.location,apiKey:e.apiKey,vertexai:e.vertexai});const r={};this.clientOptions.vertexai?(r.apiVersion=(t=this.clientOptions.apiVersion)!==null&&t!==void 0?t:tl,r.baseUrl=this.baseUrlFromProjectLocation(),this.normalizeAuthParameters()):(r.apiVersion=(o=this.clientOptions.apiVersion)!==null&&o!==void 0?o:ol,r.baseUrl="https://generativelanguage.googleapis.com/"),r.headers=this.getDefaultHeaders(),this.clientOptions.httpOptions=r,e.httpOptions&&(this.clientOptions.httpOptions=this.patchHttpOptions(r,e.httpOptions))}baseUrlFromProjectLocation(){return this.clientOptions.project&&this.clientOptions.location&&this.clientOptions.location!=="global"?`https://${this.clientOptions.location}-aiplatform.googleapis.com/`:"https://aiplatform.googleapis.com/"}normalizeAuthParameters(){if(this.clientOptions.project&&this.clientOptions.location){this.clientOptions.apiKey=void 0;return}this.clientOptions.project=void 0,this.clientOptions.location=void 0}isVertexAI(){var e;return(e=this.clientOptions.vertexai)!==null&&e!==void 0?e:!1}getProject(){return this.clientOptions.project}getLocation(){return this.clientOptions.location}getApiVersion(){if(this.clientOptions.httpOptions&&this.clientOptions.httpOptions.apiVersion!==void 0)return this.clientOptions.httpOptions.apiVersion;throw new Error("API version is not set.")}getBaseUrl(){if(this.clientOptions.httpOptions&&this.clientOptions.httpOptions.baseUrl!==void 0)return this.clientOptions.httpOptions.baseUrl;throw new Error("Base URL is not set.")}getRequestUrl(){return this.getRequestUrlInternal(this.clientOptions.httpOptions)}getHeaders(){if(this.clientOptions.httpOptions&&this.clientOptions.httpOptions.headers!==void 0)return this.clientOptions.httpOptions.headers;throw new Error("Headers are not set.")}getRequestUrlInternal(e){if(!e||e.baseUrl===void 0||e.apiVersion===void 0)throw new Error("HTTP options are not correctly set.");const o=[e.baseUrl.endsWith("/")?e.baseUrl.slice(0,-1):e.baseUrl];return e.apiVersion&&e.apiVersion!==""&&o.push(e.apiVersion),o.join("/")}getBaseResourcePath(){return`projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`}getApiKey(){return this.clientOptions.apiKey}getWebsocketBaseUrl(){const e=this.getBaseUrl(),t=new URL(e);return t.protocol=t.protocol=="http:"?"ws":"wss",t.toString()}setBaseUrl(e){if(this.clientOptions.httpOptions)this.clientOptions.httpOptions.baseUrl=e;else throw new Error("HTTP options are not correctly set.")}constructUrl(e,t,o){const r=[this.getRequestUrlInternal(t)];return o&&r.push(this.getBaseResourcePath()),e!==""&&r.push(e),new URL(`${r.join("/")}`)}shouldPrependVertexProjectPath(e){return!(this.clientOptions.apiKey||!this.clientOptions.vertexai||e.path.startsWith("projects/")||e.httpMethod==="GET"&&e.path.startsWith("publishers/google/models"))}async request(e){let t=this.clientOptions.httpOptions;e.httpOptions&&(t=this.patchHttpOptions(this.clientOptions.httpOptions,e.httpOptions));const o=this.shouldPrependVertexProjectPath(e),r=this.constructUrl(e.path,t,o);if(e.queryParams)for(const[a,u]of Object.entries(e.queryParams))r.searchParams.append(a,String(u));let l={};if(e.httpMethod==="GET"){if(e.body&&e.body!=="{}")throw new Error("Request body should be empty for GET request, but got non empty request body")}else l.body=e.body;return l=await this.includeExtraHttpOptionsToRequestInit(l,t,r.toString(),e.abortSignal),this.unaryApiCall(r,l,e.httpMethod)}patchHttpOptions(e,t){const o=JSON.parse(JSON.stringify(e));for(const[r,l]of Object.entries(t))typeof l=="object"?o[r]=Object.assign(Object.assign({},o[r]),l):l!==void 0&&(o[r]=l);return o}async requestStream(e){let t=this.clientOptions.httpOptions;e.httpOptions&&(t=this.patchHttpOptions(this.clientOptions.httpOptions,e.httpOptions));const o=this.shouldPrependVertexProjectPath(e),r=this.constructUrl(e.path,t,o);(!r.searchParams.has("alt")||r.searchParams.get("alt")!=="sse")&&r.searchParams.set("alt","sse");let l={};return l.body=e.body,l=await this.includeExtraHttpOptionsToRequestInit(l,t,r.toString(),e.abortSignal),this.streamApiCall(r,l,e.httpMethod)}async includeExtraHttpOptionsToRequestInit(e,t,o,r){if(t&&t.timeout||r){const l=new AbortController,a=l.signal;if(t.timeout&&(t==null?void 0:t.timeout)>0){const u=setTimeout(()=>l.abort(),t.timeout);u&&typeof u.unref=="function"&&u.unref()}r&&r.addEventListener("abort",()=>{l.abort()}),e.signal=a}return t&&t.extraBody!==null&&sl(e,t.extraBody),e.headers=await this.getHeadersInternal(t,o),e}async unaryApiCall(e,t,o){return this.apiCall(e.toString(),Object.assign(Object.assign({},t),{method:o})).then(async r=>(await zn(r),new pe(r))).catch(r=>{throw r instanceof Error?r:new Error(JSON.stringify(r))})}async streamApiCall(e,t,o){return this.apiCall(e.toString(),Object.assign(Object.assign({},t),{method:o})).then(async r=>(await zn(r),this.processStreamResponse(r))).catch(r=>{throw r instanceof Error?r:new Error(JSON.stringify(r))})}processStreamResponse(e){var t;return K(this,arguments,function*(){const r=(t=e==null?void 0:e.body)===null||t===void 0?void 0:t.getReader(),l=new TextDecoder("utf-8");if(!r)throw new Error("Response body is empty");try{let a="";for(;;){const{done:u,value:c}=yield w(r.read());if(u){if(a.trim().length>0)throw new Error("Incomplete JSON segment at the end");break}const d=l.decode(c,{stream:!0});try{const p=JSON.parse(d);if("error"in p){const h=JSON.parse(JSON.stringify(p.error)),m=h.status,g=h.code,T=`got status: ${m}. ${JSON.stringify(p)}`;if(g>=400&&g<600)throw new re({message:T,status:g})}}catch(p){if(p.name==="ApiError")throw p}a+=d;let f=a.match(Kn);for(;f;){const p=f[1];try{const h=new Response(p,{headers:e==null?void 0:e.headers,status:e==null?void 0:e.status,statusText:e==null?void 0:e.statusText});yield yield w(new pe(h)),a=a.slice(f[0].length),f=a.match(Kn)}catch(h){throw new Error(`exception parsing stream chunk ${p}. ${h}`)}}}}finally{r.releaseLock()}})}async apiCall(e,t){return fetch(e,t).catch(o=>{throw new Error(`exception ${o} sending request`)})}getDefaultHeaders(){const e={},t=nl+" "+this.clientOptions.userAgentExtra;return e[jr]=t,e[ye]=t,e[Qr]="application/json",e}async getHeadersInternal(e,t){const o=new Headers;if(e&&e.headers){for(const[r,l]of Object.entries(e.headers))o.append(r,l);e.timeout&&e.timeout>0&&o.append(Zr,String(Math.ceil(e.timeout/1e3)))}return await this.clientOptions.auth.addAuthHeaders(o,t),o}getFileName(e){var t;let o="";return typeof e=="string"&&(o=e.replace(/[/\\]+$/,""),o=(t=o.split(/[/\\]/).pop())!==null&&t!==void 0?t:""),o}async uploadFile(e,t){var o;const r={};t!=null&&(r.mimeType=t.mimeType,r.name=t.name,r.displayName=t.displayName),r.name&&!r.name.startsWith("files/")&&(r.name=`files/${r.name}`);const l=this.clientOptions.uploader,a=await l.stat(e);r.sizeBytes=String(a.size);const u=(o=t==null?void 0:t.mimeType)!==null&&o!==void 0?o:a.type;if(u===void 0||u==="")throw new Error("Can not determine mimeType. Please provide mimeType in the config.");r.mimeType=u;const c={file:r},d=this.getFileName(e),f=y("upload/v1beta/files",c._url),p=await this.fetchUploadUrl(f,r.sizeBytes,r.mimeType,d,c,t==null?void 0:t.httpOptions);return l.upload(e,p,this)}async uploadFileToFileSearchStore(e,t,o){var r;const l=this.clientOptions.uploader,a=await l.stat(t),u=String(a.size),c=(r=o==null?void 0:o.mimeType)!==null&&r!==void 0?r:a.type;if(c===void 0||c==="")throw new Error("Can not determine mimeType. Please provide mimeType in the config.");const d=`upload/v1beta/${e}:uploadToFileSearchStore`,f=this.getFileName(t),p={};o!=null&&o.customMetadata&&(p.customMetadata=o.customMetadata),o!=null&&o.chunkingConfig&&(p.chunkingConfig=o.chunkingConfig);const h=await this.fetchUploadUrl(d,u,c,f,p,o==null?void 0:o.httpOptions);return l.uploadToFileSearchStore(t,h,this)}async downloadFile(e){await this.clientOptions.downloader.download(e,this)}async fetchUploadUrl(e,t,o,r,l,a){var u;let c={};a?c=a:c={apiVersion:"",headers:Object.assign({"Content-Type":"application/json","X-Goog-Upload-Protocol":"resumable","X-Goog-Upload-Command":"start","X-Goog-Upload-Header-Content-Length":`${t}`,"X-Goog-Upload-Header-Content-Type":`${o}`},r?{"X-Goog-Upload-File-Name":r}:{})};const d=await this.request({path:e,body:JSON.stringify(l),httpMethod:"POST",httpOptions:c});if(!d||!(d!=null&&d.headers))throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");const f=(u=d==null?void 0:d.headers)===null||u===void 0?void 0:u["x-goog-upload-url"];if(f===void 0)throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");return f}}async function zn(n){var e;if(n===void 0)throw new Error("response is undefined");if(!n.ok){const t=n.status;let o;!((e=n.headers.get("content-type"))===null||e===void 0)&&e.includes("application/json")?o=await n.json():o={error:{message:await n.text(),code:n.status,status:n.statusText}};const r=JSON.stringify(o);throw t>=400&&t<600?new re({message:r,status:t}):new Error(r)}}function sl(n,e){if(!e||Object.keys(e).length===0)return;if(n.body instanceof Blob){console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");return}let t={};if(typeof n.body=="string"&&n.body.length>0)try{const l=JSON.parse(n.body);if(typeof l=="object"&&l!==null&&!Array.isArray(l))t=l;else{console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");return}}catch{console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");return}function o(l,a){const u=Object.assign({},l);for(const c in a)if(Object.prototype.hasOwnProperty.call(a,c)){const d=a[c],f=u[c];d&&typeof d=="object"&&!Array.isArray(d)&&f&&typeof f=="object"&&!Array.isArray(f)?u[c]=o(f,d):(f&&d&&typeof f!=typeof d&&console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${c}". Original type: ${typeof f}, New type: ${typeof d}. Overwriting.`),u[c]=d)}return u}const r=o(t,e);n.body=JSON.stringify(r)}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const rl="mcp_used/unknown";let ll=!1;function vt(n){for(const e of n)if(al(e)||typeof e=="object"&&"inputSchema"in e)return!0;return ll}function At(n){var e;const t=(e=n[ye])!==null&&e!==void 0?e:"";n[ye]=(t+` ${rl}`).trimStart()}function al(n){return n!==null&&typeof n=="object"&&n instanceof Pe}function ul(n,e=100){return K(this,arguments,function*(){let o,r=0;for(;r<e;){const l=yield w(n.listTools({cursor:o}));for(const a of l.tools)yield yield w(a),r++;if(!l.nextCursor)break;o=l.nextCursor}})}class Pe{constructor(e=[],t){this.mcpTools=[],this.functionNameToMcpClient={},this.mcpClients=e,this.config=t}static create(e,t){return new Pe(e,t)}async initialize(){var e,t,o,r;if(this.mcpTools.length>0)return;const l={},a=[];for(const f of this.mcpClients)try{for(var u=!0,c=(t=void 0,j(ul(f))),d;d=await c.next(),e=d.done,!e;u=!0){r=d.value,u=!1;const p=r;a.push(p);const h=p.name;if(l[h])throw new Error(`Duplicate function name ${h} found in MCP tools. Please ensure function names are unique.`);l[h]=f}}catch(p){t={error:p}}finally{try{!u&&!e&&(o=c.return)&&await o.call(c)}finally{if(t)throw t.error}}this.mcpTools=a,this.functionNameToMcpClient=l}async tool(){return await this.initialize(),ho(this.mcpTools,this.config)}async callTool(e){await this.initialize();const t=[];for(const o of e)if(o.name in this.functionNameToMcpClient){const r=this.functionNameToMcpClient[o.name];let l;this.config.timeout&&(l={timeout:this.config.timeout});const a=await r.callTool({name:o.name,arguments:o.args},void 0,l);t.push({functionResponse:{name:o.name,response:a.isError?{error:a}:a}})}return t}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */async function dl(n,e,t){const o=new so;let r;t.data instanceof Blob?r=JSON.parse(await t.data.text()):r=JSON.parse(t.data),Object.assign(o,r),e(o)}class cl{constructor(e,t,o){this.apiClient=e,this.auth=t,this.webSocketFactory=o}async connect(e){var t,o;if(this.apiClient.isVertexAI())throw new Error("Live music is not supported for Vertex AI.");console.warn("Live music generation is experimental and may change in future versions.");const r=this.apiClient.getWebsocketBaseUrl(),l=this.apiClient.getApiVersion(),a=hl(this.apiClient.getDefaultHeaders()),u=this.apiClient.getApiKey(),c=`${r}/ws/google.ai.generativelanguage.${l}.GenerativeService.BidiGenerateMusic?key=${u}`;let d=()=>{};const f=new Promise(E=>{d=E}),p=e.callbacks,h=function(){d({})},m=this.apiClient,g={onopen:h,onmessage:E=>{dl(m,p.onmessage,E)},onerror:(t=p==null?void 0:p.onerror)!==null&&t!==void 0?t:function(E){},onclose:(o=p==null?void 0:p.onclose)!==null&&o!==void 0?o:function(E){}},T=this.webSocketFactory.create(c,pl(a),g);T.connect(),await f;const S={setup:{model:M(this.apiClient,e.model)}};return T.send(JSON.stringify(S)),new fl(T,this.apiClient)}}class fl{constructor(e,t){this.conn=e,this.apiClient=t}async setWeightedPrompts(e){if(!e.weightedPrompts||Object.keys(e.weightedPrompts).length===0)throw new Error("Weighted prompts must be set and contain at least one entry.");const t=os(e);this.conn.send(JSON.stringify({clientContent:t}))}async setMusicGenerationConfig(e){e.musicGenerationConfig||(e.musicGenerationConfig={});const t=ts(e);this.conn.send(JSON.stringify(t))}sendPlaybackControl(e){const t={playbackControl:e};this.conn.send(JSON.stringify(t))}play(){this.sendPlaybackControl(W.PLAY)}pause(){this.sendPlaybackControl(W.PAUSE)}stop(){this.sendPlaybackControl(W.STOP)}resetContext(){this.sendPlaybackControl(W.RESET_CONTEXT)}close(){this.conn.close()}}function pl(n){const e={};return n.forEach((t,o)=>{e[o]=t}),e}function hl(n){const e=new Headers;for(const[t,o]of Object.entries(n))e.append(t,o);return e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const ml="FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";async function gl(n,e,t){const o=new io;let r;t.data instanceof Blob?r=await t.data.text():t.data instanceof ArrayBuffer?r=new TextDecoder().decode(t.data):r=t.data;const l=JSON.parse(r);if(n.isVertexAI()){const a=rs(l);Object.assign(o,a)}else Object.assign(o,l);e(o)}class Tl{constructor(e,t,o){this.apiClient=e,this.auth=t,this.webSocketFactory=o,this.music=new cl(this.apiClient,this.auth,this.webSocketFactory)}async connect(e){var t,o,r,l,a,u;if(e.config&&e.config.httpOptions)throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");const c=this.apiClient.getWebsocketBaseUrl(),d=this.apiClient.getApiVersion();let f;const p=this.apiClient.getHeaders();e.config&&e.config.tools&&vt(e.config.tools)&&At(p);const h=_l(p);if(this.apiClient.isVertexAI())f=`${c}/ws/google.cloud.aiplatform.${d}.LlmBidiService/BidiGenerateContent`,await this.auth.addAuthHeaders(h,f);else{const v=this.apiClient.getApiKey();let N="BidiGenerateContent",k="key";v!=null&&v.startsWith("auth_tokens/")&&(console.warn("Warning: Ephemeral token support is experimental and may change in future versions."),d!=="v1alpha"&&console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection."),N="BidiGenerateContentConstrained",k="access_token"),f=`${c}/ws/google.ai.generativelanguage.${d}.GenerativeService.${N}?${k}=${v}`}let m=()=>{};const g=new Promise(v=>{m=v}),T=e.callbacks,C=function(){var v;(v=T==null?void 0:T.onopen)===null||v===void 0||v.call(T),m({})},_=this.apiClient,S={onopen:C,onmessage:v=>{gl(_,T.onmessage,v)},onerror:(t=T==null?void 0:T.onerror)!==null&&t!==void 0?t:function(v){},onclose:(o=T==null?void 0:T.onclose)!==null&&o!==void 0?o:function(v){}},E=this.webSocketFactory.create(f,Cl(h),S);E.connect(),await g;let I=M(this.apiClient,e.model);if(this.apiClient.isVertexAI()&&I.startsWith("publishers/")){const v=this.apiClient.getProject(),N=this.apiClient.getLocation();I=`projects/${v}/locations/${N}/`+I}let A={};this.apiClient.isVertexAI()&&((r=e.config)===null||r===void 0?void 0:r.responseModalities)===void 0&&(e.config===void 0?e.config={responseModalities:[te.AUDIO]}:e.config.responseModalities=[te.AUDIO]),!((l=e.config)===null||l===void 0)&&l.generationConfig&&console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");const R=(u=(a=e.config)===null||a===void 0?void 0:a.tools)!==null&&u!==void 0?u:[],P=[];for(const v of R)if(this.isCallableTool(v)){const N=v;P.push(await N.tool())}else P.push(v);P.length>0&&(e.config.tools=P);const x={model:I,config:e.config,callbacks:e.callbacks};return this.apiClient.isVertexAI()?A=ns(this.apiClient,x):A=es(this.apiClient,x),delete A.config,E.send(JSON.stringify(A)),new El(E,this.apiClient)}isCallableTool(e){return"callTool"in e&&typeof e.callTool=="function"}}const yl={turnComplete:!0};class El{constructor(e,t){this.conn=e,this.apiClient=t}tLiveClientContent(e,t){if(t.turns!==null&&t.turns!==void 0){let o=[];try{o=F(t.turns),e.isVertexAI()||(o=o.map(r=>le(r)))}catch{throw new Error(`Failed to parse client content "turns", type: '${typeof t.turns}'`)}return{clientContent:{turns:o,turnComplete:t.turnComplete}}}return{clientContent:{turnComplete:t.turnComplete}}}tLiveClienttToolResponse(e,t){let o=[];if(t.functionResponses==null)throw new Error("functionResponses is required.");if(Array.isArray(t.functionResponses)?o=t.functionResponses:o=[t.functionResponses],o.length===0)throw new Error("functionResponses is required.");for(const l of o){if(typeof l!="object"||l===null||!("name"in l)||!("response"in l))throw new Error(`Could not parse function response, type '${typeof l}'.`);if(!e.isVertexAI()&&!("id"in l))throw new Error(ml)}return{toolResponse:{functionResponses:o}}}sendClientContent(e){e=Object.assign(Object.assign({},yl),e);const t=this.tLiveClientContent(this.apiClient,e);this.conn.send(JSON.stringify(t))}sendRealtimeInput(e){let t={};this.apiClient.isVertexAI()?t={realtimeInput:ss(e)}:t={realtimeInput:is(e)},this.conn.send(JSON.stringify(t))}sendToolResponse(e){if(e.functionResponses==null)throw new Error("Tool response parameters are required.");const t=this.tLiveClienttToolResponse(this.apiClient,e);this.conn.send(JSON.stringify(t))}close(){this.conn.close()}}function Cl(n){const e={};return n.forEach((t,o)=>{e[o]=t}),e}function _l(n){const e=new Headers;for(const[t,o]of Object.entries(n))e.append(t,o);return e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const On=10;function Xn(n){var e,t,o;if(!((e=n==null?void 0:n.automaticFunctionCalling)===null||e===void 0)&&e.disable)return!0;let r=!1;for(const a of(t=n==null?void 0:n.tools)!==null&&t!==void 0?t:[])if(z(a)){r=!0;break}if(!r)return!0;const l=(o=n==null?void 0:n.automaticFunctionCalling)===null||o===void 0?void 0:o.maximumRemoteCalls;return l&&(l<0||!Number.isInteger(l))||l==0?(console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:",l),!0):!1}function z(n){return"callTool"in n&&typeof n.callTool=="function"}function Sl(n){var e,t,o;return(o=(t=(e=n.config)===null||e===void 0?void 0:e.tools)===null||t===void 0?void 0:t.some(r=>z(r)))!==null&&o!==void 0?o:!1}function Qn(n){var e;const t=[];return!((e=n==null?void 0:n.config)===null||e===void 0)&&e.tools&&n.config.tools.forEach((o,r)=>{if(z(o))return;const l=o;l.functionDeclarations&&l.functionDeclarations.length>0&&t.push(r)}),t}function Zn(n){var e;return!(!((e=n==null?void 0:n.automaticFunctionCalling)===null||e===void 0)&&e.ignoreCallHistory)}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Il extends B{constructor(e){super(),this.apiClient=e,this.generateContent=async t=>{var o,r,l,a,u;const c=await this.processParamsMaybeAddMcpUsage(t);if(this.maybeMoveToResponseJsonSchem(t),!Sl(t)||Xn(t.config))return await this.generateContentInternal(c);const d=Qn(t);if(d.length>0){const T=d.map(C=>`tools[${C}]`).join(", ");throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${T}.`)}let f,p;const h=F(c.contents),m=(l=(r=(o=c.config)===null||o===void 0?void 0:o.automaticFunctionCalling)===null||r===void 0?void 0:r.maximumRemoteCalls)!==null&&l!==void 0?l:On;let g=0;for(;g<m&&(f=await this.generateContentInternal(c),!(!f.functionCalls||f.functionCalls.length===0));){const T=f.candidates[0].content,C=[];for(const _ of(u=(a=t.config)===null||a===void 0?void 0:a.tools)!==null&&u!==void 0?u:[])if(z(_)){const E=await _.callTool(f.functionCalls);C.push(...E)}g++,p={role:"user",parts:C},c.contents=F(c.contents),c.contents.push(T),c.contents.push(p),Zn(c.config)&&(h.push(T),h.push(p))}return Zn(c.config)&&(f.automaticFunctionCallingHistory=h),f},this.generateContentStream=async t=>{if(this.maybeMoveToResponseJsonSchem(t),Xn(t.config)){const r=await this.processParamsMaybeAddMcpUsage(t);return await this.generateContentStreamInternal(r)}const o=Qn(t);if(o.length>0){const r=o.map(l=>`tools[${l}]`).join(", ");throw new Error(`Incompatible tools found at ${r}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`)}return await this.processAfcStream(t)},this.generateImages=async t=>await this.generateImagesInternal(t).then(o=>{var r;let l;const a=[];if(o!=null&&o.generatedImages)for(const c of o.generatedImages)c&&(c!=null&&c.safetyAttributes)&&((r=c==null?void 0:c.safetyAttributes)===null||r===void 0?void 0:r.contentType)==="Positive Prompt"?l=c==null?void 0:c.safetyAttributes:a.push(c);let u;return l?u={generatedImages:a,positivePromptSafetyAttributes:l,sdkHttpResponse:o.sdkHttpResponse}:u={generatedImages:a,sdkHttpResponse:o.sdkHttpResponse},u}),this.list=async t=>{var o;const a={config:Object.assign(Object.assign({},{queryBase:!0}),t==null?void 0:t.config)};if(this.apiClient.isVertexAI()&&!a.config.queryBase){if(!((o=a.config)===null||o===void 0)&&o.filter)throw new Error("Filtering tuned models list for Vertex AI is not currently supported");a.config.filter="labels.tune-type:*"}return new Y(H.PAGED_ITEM_MODELS,u=>this.listInternal(u),await this.listInternal(a),a)},this.editImage=async t=>{const o={model:t.model,prompt:t.prompt,referenceImages:[],config:t.config};return t.referenceImages&&t.referenceImages&&(o.referenceImages=t.referenceImages.map(r=>r.toReferenceImageAPI())),await this.editImageInternal(o)},this.upscaleImage=async t=>{let o={numberOfImages:1,mode:"upscale"};t.config&&(o=Object.assign(Object.assign({},o),t.config));const r={model:t.model,image:t.image,upscaleFactor:t.upscaleFactor,config:o};return await this.upscaleImageInternal(r)},this.generateVideos=async t=>{var o,r,l,a,u,c;if((t.prompt||t.image||t.video)&&t.source)throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");return this.apiClient.isVertexAI()||(!((o=t.video)===null||o===void 0)&&o.uri&&(!((r=t.video)===null||r===void 0)&&r.videoBytes)?t.video={uri:t.video.uri,mimeType:t.video.mimeType}:!((a=(l=t.source)===null||l===void 0?void 0:l.video)===null||a===void 0)&&a.uri&&(!((c=(u=t.source)===null||u===void 0?void 0:u.video)===null||c===void 0)&&c.videoBytes)&&(t.source.video={uri:t.source.video.uri,mimeType:t.source.video.mimeType})),await this.generateVideosInternal(t)}}maybeMoveToResponseJsonSchem(e){e.config&&e.config.responseSchema&&(e.config.responseJsonSchema||Object.keys(e.config.responseSchema).includes("$schema")&&(e.config.responseJsonSchema=e.config.responseSchema,delete e.config.responseSchema))}async processParamsMaybeAddMcpUsage(e){var t,o,r;const l=(t=e.config)===null||t===void 0?void 0:t.tools;if(!l)return e;const a=await Promise.all(l.map(async c=>z(c)?await c.tool():c)),u={model:e.model,contents:e.contents,config:Object.assign(Object.assign({},e.config),{tools:a})};if(u.config.tools=a,e.config&&e.config.tools&&vt(e.config.tools)){const c=(r=(o=e.config.httpOptions)===null||o===void 0?void 0:o.headers)!==null&&r!==void 0?r:{};let d=Object.assign({},c);Object.keys(d).length===0&&(d=this.apiClient.getDefaultHeaders()),At(d),u.config.httpOptions=Object.assign(Object.assign({},e.config.httpOptions),{headers:d})}return u}async initAfcToolsMap(e){var t,o,r;const l=new Map;for(const a of(o=(t=e.config)===null||t===void 0?void 0:t.tools)!==null&&o!==void 0?o:[])if(z(a)){const u=a,c=await u.tool();for(const d of(r=c.functionDeclarations)!==null&&r!==void 0?r:[]){if(!d.name)throw new Error("Function declaration name is required.");if(l.has(d.name))throw new Error(`Duplicate tool declaration name: ${d.name}`);l.set(d.name,u)}}return l}async processAfcStream(e){var t,o,r;const l=(r=(o=(t=e.config)===null||t===void 0?void 0:t.automaticFunctionCalling)===null||o===void 0?void 0:o.maximumRemoteCalls)!==null&&r!==void 0?r:On;let a=!1,u=0;const c=await this.initAfcToolsMap(e);return(function(d,f,p){var h,m;return K(this,arguments,function*(){for(var g,T,C,_;u<l;){a&&(u++,a=!1);const A=yield w(d.processParamsMaybeAddMcpUsage(p)),R=yield w(d.generateContentStreamInternal(A)),P=[],x=[];try{for(var S=!0,E=(T=void 0,j(R)),I;I=yield w(E.next()),g=I.done,!g;S=!0){_=I.value,S=!1;const v=_;if(yield yield w(v),v.candidates&&(!((h=v.candidates[0])===null||h===void 0)&&h.content)){x.push(v.candidates[0].content);for(const N of(m=v.candidates[0].content.parts)!==null&&m!==void 0?m:[])if(u<l&&N.functionCall){if(!N.functionCall.name)throw new Error("Function call name was not returned by the model.");if(f.has(N.functionCall.name)){const k=yield w(f.get(N.functionCall.name).callTool([N.functionCall]));P.push(...k)}else throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${f.keys()}, mising tool: ${N.functionCall.name}`)}}}}catch(v){T={error:v}}finally{try{!S&&!g&&(C=E.return)&&(yield w(C.call(E)))}finally{if(T)throw T.error}}if(P.length>0){a=!0;const v=new Z;v.candidates=[{content:{role:"user",parts:P}}],yield yield w(v);const N=[];N.push(...x),N.push({role:"user",parts:P});const k=F(p.contents).concat(N);p.contents=k}else break}})})(this,c,e)}async generateContentInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Yn(this.apiClient,e);return u=y("{model}:generateContent",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=$n(f),h=new Z;return Object.assign(h,p),h})}else{const d=bn(this.apiClient,e);return u=y("{model}:generateContent",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Wn(f),h=new Z;return Object.assign(h,p),h})}}async generateContentStreamInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Yn(this.apiClient,e);return u=y("{model}:streamGenerateContent?alt=sse",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.requestStream({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}),a.then(function(p){return K(this,arguments,function*(){var h,m,g,T;try{for(var C=!0,_=j(p),S;S=yield w(_.next()),h=S.done,!h;C=!0){T=S.value,C=!1;const E=T,I=$n(yield w(E.json()));I.sdkHttpResponse={headers:E.headers};const A=new Z;Object.assign(A,I),yield yield w(A)}}catch(E){m={error:E}}finally{try{!C&&!h&&(g=_.return)&&(yield w(g.call(_)))}finally{if(m)throw m.error}}})})}else{const d=bn(this.apiClient,e);return u=y("{model}:streamGenerateContent?alt=sse",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.requestStream({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}),a.then(function(p){return K(this,arguments,function*(){var h,m,g,T;try{for(var C=!0,_=j(p),S;S=yield w(_.next()),h=S.done,!h;C=!0){T=S.value,C=!1;const E=T,I=Wn(yield w(E.json()));I.sdkHttpResponse={headers:E.headers};const A=new Z;Object.assign(A,I),yield yield w(A)}}catch(E){m={error:E}}finally{try{!C&&!h&&(g=_.return)&&(yield w(g.call(_)))}finally{if(m)throw m.error}}})})}}async embedContent(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Fs(this.apiClient,e);return u=y("{model}:predict",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Gs(f),h=new Pn;return Object.assign(h,p),h})}else{const d=Ls(this.apiClient,e);return u=y("{model}:batchEmbedContents",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Vs(f),h=new Pn;return Object.assign(h,p),h})}}async generateImagesInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Ks(this.apiClient,e);return u=y("{model}:predict",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Os(f),h=new Mn;return Object.assign(h,p),h})}else{const d=$s(this.apiClient,e);return u=y("{model}:predict",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=zs(f),h=new Mn;return Object.assign(h,p),h})}}async editImageInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI()){const u=Ds(this.apiClient,e);return l=y("{model}:predict",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json().then(d=>{const f=d;return f.sdkHttpResponse={headers:c.headers},f})),r.then(c=>{const d=Us(c),f=new Kt;return Object.assign(f,d),f})}else throw new Error("This method is only supported by the Vertex AI.")}async upscaleImageInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI()){const u=Yr(this.apiClient,e);return l=y("{model}:predict",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json().then(d=>{const f=d;return f.sdkHttpResponse={headers:c.headers},f})),r.then(c=>{const d=Wr(c),f=new zt;return Object.assign(f,d),f})}else throw new Error("This method is only supported by the Vertex AI.")}async recontextImage(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI()){const u=Rr(this.apiClient,e);return l=y("{model}:predict",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>{const d=Pr(c),f=new Ot;return Object.assign(f,d),f})}else throw new Error("This method is only supported by the Vertex AI.")}async segmentImage(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI()){const u=kr(this.apiClient,e);return l=y("{model}:predict",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>{const d=xr(c),f=new Xt;return Object.assign(f,d),f})}else throw new Error("This method is only supported by the Vertex AI.")}async get(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=fr(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a.then(f=>Te(f))}else{const d=cr(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a.then(f=>ge(f))}}async listInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Er(this.apiClient,e);return u=y("{models_url}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=_r(f),h=new Nn;return Object.assign(h,p),h})}else{const d=yr(this.apiClient,e);return u=y("{models_url}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Cr(f),h=new Nn;return Object.assign(h,p),h})}}async update(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Jr(this.apiClient,e);return u=y("{model}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"PATCH",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a.then(f=>Te(f))}else{const d=Br(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"PATCH",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a.then(f=>ge(f))}}async delete(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Ps(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"DELETE",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Ns(f),h=new wn;return Object.assign(h,p),h})}else{const d=Rs(this.apiClient,e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"DELETE",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Ms(f),h=new wn;return Object.assign(h,p),h})}}async countTokens(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Is(this.apiClient,e);return u=y("{model}:countTokens",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=As(f),h=new Dn;return Object.assign(h,p),h})}else{const d=Ss(this.apiClient,e);return u=y("{model}:countTokens",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=vs(f),h=new Dn;return Object.assign(h,p),h})}}async computeTokens(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI()){const u=ms(this.apiClient,e);return l=y("{model}:computeTokens",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json().then(d=>{const f=d;return f.sdkHttpResponse={headers:c.headers},f})),r.then(c=>{const d=gs(c),f=new Qt;return Object.assign(f,d),f})}else throw new Error("This method is only supported by the Vertex AI.")}async generateVideosInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=nr(this.apiClient,e);return u=y("{model}:predictLongRunning",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a.then(f=>{const p=js(f),h=new oe;return Object.assign(h,p),h})}else{const d=er(this.apiClient,e);return u=y("{model}:predictLongRunning",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a.then(f=>{const p=Zs(f),h=new oe;return Object.assign(h,p),h})}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class vl extends B{constructor(e){super(),this.apiClient=e}async getVideosOperation(e){const t=e.operation,o=e.config;if(t.name===void 0||t.name==="")throw new Error("Operation name is required.");if(this.apiClient.isVertexAI()){const r=t.name.split("/operations/")[0];let l;o&&"httpOptions"in o&&(l=o.httpOptions);const a=await this.fetchPredictVideosOperationInternal({operationName:t.name,resourceName:r,config:{httpOptions:l}});return t._fromAPIResponse({apiResponse:a,_isVertexAI:!0})}else{const r=await this.getVideosOperationInternal({operationName:t.name,config:o});return t._fromAPIResponse({apiResponse:r,_isVertexAI:!1})}}async get(e){const t=e.operation,o=e.config;if(t.name===void 0||t.name==="")throw new Error("Operation name is required.");if(this.apiClient.isVertexAI()){const r=t.name.split("/operations/")[0];let l;o&&"httpOptions"in o&&(l=o.httpOptions);const a=await this.fetchPredictVideosOperationInternal({operationName:t.name,resourceName:r,config:{httpOptions:l}});return t._fromAPIResponse({apiResponse:a,_isVertexAI:!0})}else{const r=await this.getVideosOperationInternal({operationName:t.name,config:o});return t._fromAPIResponse({apiResponse:r,_isVertexAI:!1})}}async getVideosOperationInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Bt(e);return u=y("{operationName}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json()),a}else{const d=Ht(e);return u=y("{operationName}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json()),a}}async fetchPredictVideosOperationInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI()){const u=kt(e);return l=y("{resourceName}:fetchPredictOperation",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r}else throw new Error("This method is only supported by the Vertex AI.")}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Al(n){const e={},t=i(n,["data"]);if(t!=null&&s(e,["data"],t),i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function Rl(n){const e={},t=i(n,["parts"]);if(t!=null){let r=t;Array.isArray(r)&&(r=r.map(l=>xl(l))),s(e,["parts"],r)}const o=i(n,["role"]);return o!=null&&s(e,["role"],o),e}function Pl(n,e,t){const o={},r=i(e,["expireTime"]);t!==void 0&&r!=null&&s(t,["expireTime"],r);const l=i(e,["newSessionExpireTime"]);t!==void 0&&l!=null&&s(t,["newSessionExpireTime"],l);const a=i(e,["uses"]);t!==void 0&&a!=null&&s(t,["uses"],a);const u=i(e,["liveConnectConstraints"]);t!==void 0&&u!=null&&s(t,["bidiGenerateContentSetup"],kl(n,u));const c=i(e,["lockAdditionalFields"]);return t!==void 0&&c!=null&&s(t,["fieldMask"],c),o}function Ml(n,e){const t={},o=i(e,["config"]);return o!=null&&s(t,["config"],Pl(n,o,t)),t}function Nl(n){const e={};if(i(n,["displayName"])!==void 0)throw new Error("displayName parameter is not supported in Gemini API.");const t=i(n,["fileUri"]);t!=null&&s(e,["fileUri"],t);const o=i(n,["mimeType"]);return o!=null&&s(e,["mimeType"],o),e}function wl(n){const e={};if(i(n,["authConfig"])!==void 0)throw new Error("authConfig parameter is not supported in Gemini API.");const t=i(n,["enableWidget"]);return t!=null&&s(e,["enableWidget"],t),e}function Dl(n){const e={};if(i(n,["excludeDomains"])!==void 0)throw new Error("excludeDomains parameter is not supported in Gemini API.");if(i(n,["blockingConfidence"])!==void 0)throw new Error("blockingConfidence parameter is not supported in Gemini API.");const t=i(n,["timeRangeFilter"]);return t!=null&&s(e,["timeRangeFilter"],t),e}function Ul(n,e){const t={},o=i(n,["generationConfig"]);e!==void 0&&o!=null&&s(e,["setup","generationConfig"],o);const r=i(n,["responseModalities"]);e!==void 0&&r!=null&&s(e,["setup","generationConfig","responseModalities"],r);const l=i(n,["temperature"]);e!==void 0&&l!=null&&s(e,["setup","generationConfig","temperature"],l);const a=i(n,["topP"]);e!==void 0&&a!=null&&s(e,["setup","generationConfig","topP"],a);const u=i(n,["topK"]);e!==void 0&&u!=null&&s(e,["setup","generationConfig","topK"],u);const c=i(n,["maxOutputTokens"]);e!==void 0&&c!=null&&s(e,["setup","generationConfig","maxOutputTokens"],c);const d=i(n,["mediaResolution"]);e!==void 0&&d!=null&&s(e,["setup","generationConfig","mediaResolution"],d);const f=i(n,["seed"]);e!==void 0&&f!=null&&s(e,["setup","generationConfig","seed"],f);const p=i(n,["speechConfig"]);e!==void 0&&p!=null&&s(e,["setup","generationConfig","speechConfig"],Re(p));const h=i(n,["thinkingConfig"]);e!==void 0&&h!=null&&s(e,["setup","generationConfig","thinkingConfig"],h);const m=i(n,["enableAffectiveDialog"]);e!==void 0&&m!=null&&s(e,["setup","generationConfig","enableAffectiveDialog"],m);const g=i(n,["systemInstruction"]);e!==void 0&&g!=null&&s(e,["setup","systemInstruction"],Rl(L(g)));const T=i(n,["tools"]);if(e!==void 0&&T!=null){let R=X(T);Array.isArray(R)&&(R=R.map(P=>Fl(O(P)))),s(e,["setup","tools"],R)}const C=i(n,["sessionResumption"]);e!==void 0&&C!=null&&s(e,["setup","sessionResumption"],Ll(C));const _=i(n,["inputAudioTranscription"]);e!==void 0&&_!=null&&s(e,["setup","inputAudioTranscription"],_);const S=i(n,["outputAudioTranscription"]);e!==void 0&&S!=null&&s(e,["setup","outputAudioTranscription"],S);const E=i(n,["realtimeInputConfig"]);e!==void 0&&E!=null&&s(e,["setup","realtimeInputConfig"],E);const I=i(n,["contextWindowCompression"]);e!==void 0&&I!=null&&s(e,["setup","contextWindowCompression"],I);const A=i(n,["proactivity"]);return e!==void 0&&A!=null&&s(e,["setup","proactivity"],A),t}function kl(n,e){const t={},o=i(e,["model"]);o!=null&&s(t,["setup","model"],M(n,o));const r=i(e,["config"]);return r!=null&&s(t,["config"],Ul(r,t)),t}function xl(n){const e={},t=i(n,["functionCall"]);t!=null&&s(e,["functionCall"],t);const o=i(n,["codeExecutionResult"]);o!=null&&s(e,["codeExecutionResult"],o);const r=i(n,["executableCode"]);r!=null&&s(e,["executableCode"],r);const l=i(n,["fileData"]);l!=null&&s(e,["fileData"],Nl(l));const a=i(n,["functionResponse"]);a!=null&&s(e,["functionResponse"],a);const u=i(n,["inlineData"]);u!=null&&s(e,["inlineData"],Al(u));const c=i(n,["text"]);c!=null&&s(e,["text"],c);const d=i(n,["thought"]);d!=null&&s(e,["thought"],d);const f=i(n,["thoughtSignature"]);f!=null&&s(e,["thoughtSignature"],f);const p=i(n,["videoMetadata"]);return p!=null&&s(e,["videoMetadata"],p),e}function Ll(n){const e={},t=i(n,["handle"]);if(t!=null&&s(e,["handle"],t),i(n,["transparent"])!==void 0)throw new Error("transparent parameter is not supported in Gemini API.");return e}function Fl(n){const e={},t=i(n,["functionDeclarations"]);if(t!=null){let f=t;Array.isArray(f)&&(f=f.map(p=>p)),s(e,["functionDeclarations"],f)}if(i(n,["retrieval"])!==void 0)throw new Error("retrieval parameter is not supported in Gemini API.");const o=i(n,["googleSearchRetrieval"]);o!=null&&s(e,["googleSearchRetrieval"],o);const r=i(n,["computerUse"]);r!=null&&s(e,["computerUse"],r);const l=i(n,["fileSearch"]);l!=null&&s(e,["fileSearch"],l);const a=i(n,["codeExecution"]);if(a!=null&&s(e,["codeExecution"],a),i(n,["enterpriseWebSearch"])!==void 0)throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");const u=i(n,["googleMaps"]);u!=null&&s(e,["googleMaps"],wl(u));const c=i(n,["googleSearch"]);c!=null&&s(e,["googleSearch"],Dl(c));const d=i(n,["urlContext"]);return d!=null&&s(e,["urlContext"],d),e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Vl(n){const e=[];for(const t in n)if(Object.prototype.hasOwnProperty.call(n,t)){const o=n[t];if(typeof o=="object"&&o!=null&&Object.keys(o).length>0){const r=Object.keys(o).map(l=>`${t}.${l}`);e.push(...r)}else e.push(t)}return e.join(",")}function Gl(n,e){let t=null;const o=n.bidiGenerateContentSetup;if(typeof o=="object"&&o!==null&&"setup"in o){const l=o.setup;typeof l=="object"&&l!==null?(n.bidiGenerateContentSetup=l,t=l):delete n.bidiGenerateContentSetup}else o!==void 0&&delete n.bidiGenerateContentSetup;const r=n.fieldMask;if(t){const l=Vl(t);if(Array.isArray(e==null?void 0:e.lockAdditionalFields)&&(e==null?void 0:e.lockAdditionalFields.length)===0)l?n.fieldMask=l:delete n.fieldMask;else if(e!=null&&e.lockAdditionalFields&&e.lockAdditionalFields.length>0&&r!==null&&Array.isArray(r)&&r.length>0){const a=["temperature","topK","topP","maxOutputTokens","responseModalities","seed","speechConfig"];let u=[];r.length>0&&(u=r.map(d=>a.includes(d)?`generationConfig.${d}`:d));const c=[];l&&c.push(l),u.length>0&&c.push(...u),c.length>0?n.fieldMask=c.join(","):delete n.fieldMask}else delete n.fieldMask}else r!==null&&Array.isArray(r)&&r.length>0?n.fieldMask=r.join(","):delete n.fieldMask;return n}class ql extends B{constructor(e){super(),this.apiClient=e}async create(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");{const u=Ml(this.apiClient,e);l=y("auth_tokens",u._url),a=u._query,delete u.config,delete u._url,delete u._query;const c=Gl(u,e.config);return r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(c),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(d=>d.json()),r.then(d=>d)}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Hl(n,e){const t={},o=i(n,["displayName"]);return e!==void 0&&o!=null&&s(e,["displayName"],o),t}function Bl(n){const e={},t=i(n,["config"]);return t!=null&&Hl(t,e),e}function Jl(n,e){const t={},o=i(n,["force"]);return e!==void 0&&o!=null&&s(e,["_query","force"],o),t}function bl(n){const e={},t=i(n,["name"]);t!=null&&s(e,["_url","name"],t);const o=i(n,["config"]);return o!=null&&Jl(o,e),e}function Yl(n){const e={},t=i(n,["name"]);return t!=null&&s(e,["_url","name"],t),e}function Wl(n,e){const t={},o=i(n,["customMetadata"]);if(e!==void 0&&o!=null){let l=o;Array.isArray(l)&&(l=l.map(a=>a)),s(e,["customMetadata"],l)}const r=i(n,["chunkingConfig"]);return e!==void 0&&r!=null&&s(e,["chunkingConfig"],r),t}function $l(n){const e={},t=i(n,["name"]);t!=null&&s(e,["name"],t);const o=i(n,["metadata"]);o!=null&&s(e,["metadata"],o);const r=i(n,["done"]);r!=null&&s(e,["done"],r);const l=i(n,["error"]);l!=null&&s(e,["error"],l);const a=i(n,["response"]);return a!=null&&s(e,["response"],zl(a)),e}function Kl(n){const e={},t=i(n,["fileSearchStoreName"]);t!=null&&s(e,["_url","file_search_store_name"],t);const o=i(n,["fileName"]);o!=null&&s(e,["fileName"],o);const r=i(n,["config"]);return r!=null&&Wl(r,e),e}function zl(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["parent"]);o!=null&&s(e,["parent"],o);const r=i(n,["documentName"]);return r!=null&&s(e,["documentName"],r),e}function Ol(n,e){const t={},o=i(n,["pageSize"]);e!==void 0&&o!=null&&s(e,["_query","pageSize"],o);const r=i(n,["pageToken"]);return e!==void 0&&r!=null&&s(e,["_query","pageToken"],r),t}function Xl(n){const e={},t=i(n,["config"]);return t!=null&&Ol(t,e),e}function Ql(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["fileSearchStores"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>a)),s(e,["fileSearchStores"],l)}return e}function Zl(n,e){const t={},o=i(n,["mimeType"]);e!==void 0&&o!=null&&s(e,["mimeType"],o);const r=i(n,["displayName"]);e!==void 0&&r!=null&&s(e,["displayName"],r);const l=i(n,["customMetadata"]);if(e!==void 0&&l!=null){let u=l;Array.isArray(u)&&(u=u.map(c=>c)),s(e,["customMetadata"],u)}const a=i(n,["chunkingConfig"]);return e!==void 0&&a!=null&&s(e,["chunkingConfig"],a),t}function jl(n){const e={},t=i(n,["fileSearchStoreName"]);t!=null&&s(e,["_url","file_search_store_name"],t);const o=i(n,["config"]);return o!=null&&Zl(o,e),e}function ea(n){const e={},t=i(n,["sdkHttpResponse"]);return t!=null&&s(e,["sdkHttpResponse"],t),e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function na(n,e){const t={},o=i(n,["force"]);return e!==void 0&&o!=null&&s(e,["_query","force"],o),t}function ta(n){const e={},t=i(n,["name"]);t!=null&&s(e,["_url","name"],t);const o=i(n,["config"]);return o!=null&&na(o,e),e}function oa(n){const e={},t=i(n,["name"]);return t!=null&&s(e,["_url","name"],t),e}function ia(n,e){const t={},o=i(n,["pageSize"]);e!==void 0&&o!=null&&s(e,["_query","pageSize"],o);const r=i(n,["pageToken"]);return e!==void 0&&r!=null&&s(e,["_query","pageToken"],r),t}function sa(n){const e={},t=i(n,["parent"]);t!=null&&s(e,["_url","parent"],t);const o=i(n,["config"]);return o!=null&&ia(o,e),e}function ra(n){const e={},t=i(n,["sdkHttpResponse"]);t!=null&&s(e,["sdkHttpResponse"],t);const o=i(n,["nextPageToken"]);o!=null&&s(e,["nextPageToken"],o);const r=i(n,["documents"]);if(r!=null){let l=r;Array.isArray(l)&&(l=l.map(a=>a)),s(e,["documents"],l)}return e}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class la extends B{constructor(e){super(),this.apiClient=e,this.list=async t=>new Y(H.PAGED_ITEM_DOCUMENTS,o=>this.listInternal({parent:t.parent,config:o.config}),await this.listInternal(t),t)}async get(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=oa(e);return l=y("{name}",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>c)}}async delete(e){var t,o;let r="",l={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const a=ta(e);r=y("{name}",a._url),l=a._query,delete a._url,delete a._query,await this.apiClient.request({path:r,queryParams:l,body:JSON.stringify(a),httpMethod:"DELETE",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal})}}async listInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=sa(e);return l=y("{parent}/documents",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>{const d=ra(c),f=new Zt;return Object.assign(f,d),f})}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class aa extends B{constructor(e,t=new la(e)){super(),this.apiClient=e,this.documents=t,this.list=async(o={})=>new Y(H.PAGED_ITEM_FILE_SEARCH_STORES,r=>this.listInternal(r),await this.listInternal(o),o)}async uploadToFileSearchStore(e){if(this.apiClient.isVertexAI())throw new Error("Vertex AI does not support uploading files to a file search store.");return this.apiClient.uploadFileToFileSearchStore(e.fileSearchStoreName,e.file,e.config)}async create(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=Bl(e);return l=y("fileSearchStores",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>c)}}async get(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=Yl(e);return l=y("{name}",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>c)}}async delete(e){var t,o;let r="",l={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const a=bl(e);r=y("{name}",a._url),l=a._query,delete a._url,delete a._query,await this.apiClient.request({path:r,queryParams:l,body:JSON.stringify(a),httpMethod:"DELETE",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal})}}async listInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=Xl(e);return l=y("fileSearchStores",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>{const d=Ql(c),f=new jt;return Object.assign(f,d),f})}}async uploadToFileSearchStoreInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=jl(e);return l=y("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>{const d=ea(c),f=new eo;return Object.assign(f,d),f})}}async importFile(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=Kl(e);return l=y("{file_search_store_name}:importFile",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json()),r.then(c=>{const d=$l(c),f=new _e;return Object.assign(f,d),f})}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ua(n,e){const t={},o=i(n,["name"]);return o!=null&&s(t,["_url","name"],o),t}function da(n,e){const t={},o=i(n,["name"]);return o!=null&&s(t,["_url","name"],o),t}function ca(n,e,t){const o={};if(i(n,["validationDataset"])!==void 0)throw new Error("validationDataset parameter is not supported in Gemini API.");const r=i(n,["tunedModelDisplayName"]);if(e!==void 0&&r!=null&&s(e,["displayName"],r),i(n,["description"])!==void 0)throw new Error("description parameter is not supported in Gemini API.");const l=i(n,["epochCount"]);e!==void 0&&l!=null&&s(e,["tuningTask","hyperparameters","epochCount"],l);const a=i(n,["learningRateMultiplier"]);if(a!=null&&s(o,["tuningTask","hyperparameters","learningRateMultiplier"],a),i(n,["exportLastCheckpointOnly"])!==void 0)throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");if(i(n,["preTunedModelCheckpointId"])!==void 0)throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");if(i(n,["adapterSize"])!==void 0)throw new Error("adapterSize parameter is not supported in Gemini API.");const u=i(n,["batchSize"]);e!==void 0&&u!=null&&s(e,["tuningTask","hyperparameters","batchSize"],u);const c=i(n,["learningRate"]);if(e!==void 0&&c!=null&&s(e,["tuningTask","hyperparameters","learningRate"],c),i(n,["labels"])!==void 0)throw new Error("labels parameter is not supported in Gemini API.");if(i(n,["beta"])!==void 0)throw new Error("beta parameter is not supported in Gemini API.");return o}function fa(n,e,t){const o={};let r=i(t,["config","method"]);if(r===void 0&&(r="SUPERVISED_FINE_TUNING"),r==="SUPERVISED_FINE_TUNING"){const m=i(n,["validationDataset"]);e!==void 0&&m!=null&&s(e,["supervisedTuningSpec"],jn(m))}else if(r==="PREFERENCE_TUNING"){const m=i(n,["validationDataset"]);e!==void 0&&m!=null&&s(e,["preferenceOptimizationSpec"],jn(m))}const l=i(n,["tunedModelDisplayName"]);e!==void 0&&l!=null&&s(e,["tunedModelDisplayName"],l);const a=i(n,["description"]);e!==void 0&&a!=null&&s(e,["description"],a);let u=i(t,["config","method"]);if(u===void 0&&(u="SUPERVISED_FINE_TUNING"),u==="SUPERVISED_FINE_TUNING"){const m=i(n,["epochCount"]);e!==void 0&&m!=null&&s(e,["supervisedTuningSpec","hyperParameters","epochCount"],m)}else if(u==="PREFERENCE_TUNING"){const m=i(n,["epochCount"]);e!==void 0&&m!=null&&s(e,["preferenceOptimizationSpec","hyperParameters","epochCount"],m)}let c=i(t,["config","method"]);if(c===void 0&&(c="SUPERVISED_FINE_TUNING"),c==="SUPERVISED_FINE_TUNING"){const m=i(n,["learningRateMultiplier"]);e!==void 0&&m!=null&&s(e,["supervisedTuningSpec","hyperParameters","learningRateMultiplier"],m)}else if(c==="PREFERENCE_TUNING"){const m=i(n,["learningRateMultiplier"]);e!==void 0&&m!=null&&s(e,["preferenceOptimizationSpec","hyperParameters","learningRateMultiplier"],m)}let d=i(t,["config","method"]);if(d===void 0&&(d="SUPERVISED_FINE_TUNING"),d==="SUPERVISED_FINE_TUNING"){const m=i(n,["exportLastCheckpointOnly"]);e!==void 0&&m!=null&&s(e,["supervisedTuningSpec","exportLastCheckpointOnly"],m)}else if(d==="PREFERENCE_TUNING"){const m=i(n,["exportLastCheckpointOnly"]);e!==void 0&&m!=null&&s(e,["preferenceOptimizationSpec","exportLastCheckpointOnly"],m)}let f=i(t,["config","method"]);if(f===void 0&&(f="SUPERVISED_FINE_TUNING"),f==="SUPERVISED_FINE_TUNING"){const m=i(n,["adapterSize"]);e!==void 0&&m!=null&&s(e,["supervisedTuningSpec","hyperParameters","adapterSize"],m)}else if(f==="PREFERENCE_TUNING"){const m=i(n,["adapterSize"]);e!==void 0&&m!=null&&s(e,["preferenceOptimizationSpec","hyperParameters","adapterSize"],m)}if(i(n,["batchSize"])!==void 0)throw new Error("batchSize parameter is not supported in Vertex AI.");if(i(n,["learningRate"])!==void 0)throw new Error("learningRate parameter is not supported in Vertex AI.");const p=i(n,["labels"]);e!==void 0&&p!=null&&s(e,["labels"],p);const h=i(n,["beta"]);return e!==void 0&&h!=null&&s(e,["preferenceOptimizationSpec","hyperParameters","beta"],h),o}function pa(n,e){const t={},o=i(n,["baseModel"]);o!=null&&s(t,["baseModel"],o);const r=i(n,["preTunedModel"]);r!=null&&s(t,["preTunedModel"],r);const l=i(n,["trainingDataset"]);l!=null&&va(l);const a=i(n,["config"]);return a!=null&&ca(a,t),t}function ha(n,e){const t={},o=i(n,["baseModel"]);o!=null&&s(t,["baseModel"],o);const r=i(n,["preTunedModel"]);r!=null&&s(t,["preTunedModel"],r);const l=i(n,["trainingDataset"]);l!=null&&Aa(l,t,e);const a=i(n,["config"]);return a!=null&&fa(a,t,e),t}function ma(n,e){const t={},o=i(n,["name"]);return o!=null&&s(t,["_url","name"],o),t}function ga(n,e){const t={},o=i(n,["name"]);return o!=null&&s(t,["_url","name"],o),t}function Ta(n,e,t){const o={},r=i(n,["pageSize"]);e!==void 0&&r!=null&&s(e,["_query","pageSize"],r);const l=i(n,["pageToken"]);e!==void 0&&l!=null&&s(e,["_query","pageToken"],l);const a=i(n,["filter"]);return e!==void 0&&a!=null&&s(e,["_query","filter"],a),o}function ya(n,e,t){const o={},r=i(n,["pageSize"]);e!==void 0&&r!=null&&s(e,["_query","pageSize"],r);const l=i(n,["pageToken"]);e!==void 0&&l!=null&&s(e,["_query","pageToken"],l);const a=i(n,["filter"]);return e!==void 0&&a!=null&&s(e,["_query","filter"],a),o}function Ea(n,e){const t={},o=i(n,["config"]);return o!=null&&Ta(o,t),t}function Ca(n,e){const t={},o=i(n,["config"]);return o!=null&&ya(o,t),t}function _a(n,e){const t={},o=i(n,["sdkHttpResponse"]);o!=null&&s(t,["sdkHttpResponse"],o);const r=i(n,["nextPageToken"]);r!=null&&s(t,["nextPageToken"],r);const l=i(n,["tunedModels"]);if(l!=null){let a=l;Array.isArray(a)&&(a=a.map(u=>Rt(u))),s(t,["tuningJobs"],a)}return t}function Sa(n,e){const t={},o=i(n,["sdkHttpResponse"]);o!=null&&s(t,["sdkHttpResponse"],o);const r=i(n,["nextPageToken"]);r!=null&&s(t,["nextPageToken"],r);const l=i(n,["tuningJobs"]);if(l!=null){let a=l;Array.isArray(a)&&(a=a.map(u=>Ee(u))),s(t,["tuningJobs"],a)}return t}function Ia(n,e){const t={},o=i(n,["name"]);o!=null&&s(t,["model"],o);const r=i(n,["name"]);return r!=null&&s(t,["endpoint"],r),t}function va(n,e){const t={};if(i(n,["gcsUri"])!==void 0)throw new Error("gcsUri parameter is not supported in Gemini API.");if(i(n,["vertexDatasetResource"])!==void 0)throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");const o=i(n,["examples"]);if(o!=null){let r=o;Array.isArray(r)&&(r=r.map(l=>l)),s(t,["examples","examples"],r)}return t}function Aa(n,e,t){const o={};let r=i(t,["config","method"]);if(r===void 0&&(r="SUPERVISED_FINE_TUNING"),r==="SUPERVISED_FINE_TUNING"){const a=i(n,["gcsUri"]);e!==void 0&&a!=null&&s(e,["supervisedTuningSpec","trainingDatasetUri"],a)}else if(r==="PREFERENCE_TUNING"){const a=i(n,["gcsUri"]);e!==void 0&&a!=null&&s(e,["preferenceOptimizationSpec","trainingDatasetUri"],a)}let l=i(t,["config","method"]);if(l===void 0&&(l="SUPERVISED_FINE_TUNING"),l==="SUPERVISED_FINE_TUNING"){const a=i(n,["vertexDatasetResource"]);e!==void 0&&a!=null&&s(e,["supervisedTuningSpec","trainingDatasetUri"],a)}else if(l==="PREFERENCE_TUNING"){const a=i(n,["vertexDatasetResource"]);e!==void 0&&a!=null&&s(e,["preferenceOptimizationSpec","trainingDatasetUri"],a)}if(i(n,["examples"])!==void 0)throw new Error("examples parameter is not supported in Vertex AI.");return o}function Rt(n,e){const t={},o=i(n,["sdkHttpResponse"]);o!=null&&s(t,["sdkHttpResponse"],o);const r=i(n,["name"]);r!=null&&s(t,["name"],r);const l=i(n,["state"]);l!=null&&s(t,["state"],lt(l));const a=i(n,["createTime"]);a!=null&&s(t,["createTime"],a);const u=i(n,["tuningTask","startTime"]);u!=null&&s(t,["startTime"],u);const c=i(n,["tuningTask","completeTime"]);c!=null&&s(t,["endTime"],c);const d=i(n,["updateTime"]);d!=null&&s(t,["updateTime"],d);const f=i(n,["description"]);f!=null&&s(t,["description"],f);const p=i(n,["baseModel"]);p!=null&&s(t,["baseModel"],p);const h=i(n,["_self"]);return h!=null&&s(t,["tunedModel"],Ia(h)),t}function Ee(n,e){const t={},o=i(n,["sdkHttpResponse"]);o!=null&&s(t,["sdkHttpResponse"],o);const r=i(n,["name"]);r!=null&&s(t,["name"],r);const l=i(n,["state"]);l!=null&&s(t,["state"],lt(l));const a=i(n,["createTime"]);a!=null&&s(t,["createTime"],a);const u=i(n,["startTime"]);u!=null&&s(t,["startTime"],u);const c=i(n,["endTime"]);c!=null&&s(t,["endTime"],c);const d=i(n,["updateTime"]);d!=null&&s(t,["updateTime"],d);const f=i(n,["error"]);f!=null&&s(t,["error"],f);const p=i(n,["description"]);p!=null&&s(t,["description"],p);const h=i(n,["baseModel"]);h!=null&&s(t,["baseModel"],h);const m=i(n,["tunedModel"]);m!=null&&s(t,["tunedModel"],m);const g=i(n,["preTunedModel"]);g!=null&&s(t,["preTunedModel"],g);const T=i(n,["supervisedTuningSpec"]);T!=null&&s(t,["supervisedTuningSpec"],T);const C=i(n,["preferenceOptimizationSpec"]);C!=null&&s(t,["preferenceOptimizationSpec"],C);const _=i(n,["tuningDataStats"]);_!=null&&s(t,["tuningDataStats"],_);const S=i(n,["encryptionSpec"]);S!=null&&s(t,["encryptionSpec"],S);const E=i(n,["partnerModelTuningSpec"]);E!=null&&s(t,["partnerModelTuningSpec"],E);const I=i(n,["customBaseModel"]);I!=null&&s(t,["customBaseModel"],I);const A=i(n,["experiment"]);A!=null&&s(t,["experiment"],A);const R=i(n,["labels"]);R!=null&&s(t,["labels"],R);const P=i(n,["outputUri"]);P!=null&&s(t,["outputUri"],P);const x=i(n,["pipelineJob"]);x!=null&&s(t,["pipelineJob"],x);const v=i(n,["serviceAccount"]);v!=null&&s(t,["serviceAccount"],v);const N=i(n,["tunedModelDisplayName"]);N!=null&&s(t,["tunedModelDisplayName"],N);const k=i(n,["veoTuningSpec"]);return k!=null&&s(t,["veoTuningSpec"],k),t}function Ra(n,e){const t={},o=i(n,["sdkHttpResponse"]);o!=null&&s(t,["sdkHttpResponse"],o);const r=i(n,["name"]);r!=null&&s(t,["name"],r);const l=i(n,["metadata"]);l!=null&&s(t,["metadata"],l);const a=i(n,["done"]);a!=null&&s(t,["done"],a);const u=i(n,["error"]);return u!=null&&s(t,["error"],u),t}function jn(n,e){const t={},o=i(n,["gcsUri"]);o!=null&&s(t,["validationDatasetUri"],o);const r=i(n,["vertexDatasetResource"]);return r!=null&&s(t,["validationDatasetUri"],r),t}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Pa extends B{constructor(e){super(),this.apiClient=e,this.get=async t=>await this.getInternal(t),this.list=async(t={})=>new Y(H.PAGED_ITEM_TUNING_JOBS,o=>this.listInternal(o),await this.listInternal(t),t),this.tune=async t=>{var o;if(this.apiClient.isVertexAI())if(t.baseModel.startsWith("projects/")){const r={tunedModelName:t.baseModel};!((o=t.config)===null||o===void 0)&&o.preTunedModelCheckpointId&&(r.checkpointId=t.config.preTunedModelCheckpointId);const l=Object.assign(Object.assign({},t),{preTunedModel:r});return l.baseModel=void 0,await this.tuneInternal(l)}else{const r=Object.assign({},t);return await this.tuneInternal(r)}else{const r=Object.assign({},t),l=await this.tuneMldevInternal(r);let a="";return l.metadata!==void 0&&l.metadata.tunedModel!==void 0?a=l.metadata.tunedModel:l.name!==void 0&&l.name.includes("/operations/")&&(a=l.name.split("/operations/")[0]),{name:a,state:fe.JOB_STATE_QUEUED}}}}async getInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=ga(e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>Ee(f))}else{const d=ma(e);return u=y("{name}",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>Rt(f))}}async listInternal(e){var t,o,r,l;let a,u="",c={};if(this.apiClient.isVertexAI()){const d=Ca(e);return u=y("tuningJobs",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=Sa(f),h=new Un;return Object.assign(h,p),h})}else{const d=Ea(e);return u=y("tunedModels",d._url),c=d._query,delete d._url,delete d._query,a=this.apiClient.request({path:u,queryParams:c,body:JSON.stringify(d),httpMethod:"GET",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal}).then(f=>f.json().then(p=>{const h=p;return h.sdkHttpResponse={headers:f.headers},h})),a.then(f=>{const p=_a(f),h=new Un;return Object.assign(h,p),h})}}async cancel(e){var t,o,r,l;let a="",u={};if(this.apiClient.isVertexAI()){const c=da(e);a=y("{name}:cancel",c._url),u=c._query,delete c._url,delete c._query,await this.apiClient.request({path:a,queryParams:u,body:JSON.stringify(c),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal})}else{const c=ua(e);a=y("{name}:cancel",c._url),u=c._query,delete c._url,delete c._query,await this.apiClient.request({path:a,queryParams:u,body:JSON.stringify(c),httpMethod:"POST",httpOptions:(r=e.config)===null||r===void 0?void 0:r.httpOptions,abortSignal:(l=e.config)===null||l===void 0?void 0:l.abortSignal})}}async tuneInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI()){const u=ha(e,e);return l=y("tuningJobs",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json().then(d=>{const f=d;return f.sdkHttpResponse={headers:c.headers},f})),r.then(c=>Ee(c))}else throw new Error("This method is only supported by the Vertex AI.")}async tuneMldevInternal(e){var t,o;let r,l="",a={};if(this.apiClient.isVertexAI())throw new Error("This method is only supported by the Gemini Developer API.");{const u=pa(e);return l=y("tunedModels",u._url),a=u._query,delete u._url,delete u._query,r=this.apiClient.request({path:l,queryParams:a,body:JSON.stringify(u),httpMethod:"POST",httpOptions:(t=e.config)===null||t===void 0?void 0:t.httpOptions,abortSignal:(o=e.config)===null||o===void 0?void 0:o.abortSignal}).then(c=>c.json().then(d=>{const f=d;return f.sdkHttpResponse={headers:c.headers},f})),r.then(c=>Ra(c))}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Ma{async download(e,t){throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.")}}const Na=1024*1024*8,wa=3,Da=1e3,Ua=2,se="x-goog-upload-status";async function ka(n,e,t){var o;const r=await Pt(n,e,t),l=await(r==null?void 0:r.json());if(((o=r==null?void 0:r.headers)===null||o===void 0?void 0:o[se])!=="final")throw new Error("Failed to upload file: Upload status is not finalized.");return l.file}async function xa(n,e,t){var o;const r=await Pt(n,e,t),l=await(r==null?void 0:r.json());if(((o=r==null?void 0:r.headers)===null||o===void 0?void 0:o[se])!=="final")throw new Error("Failed to upload file: Upload status is not finalized.");const a=nt(l),u=new Se;return Object.assign(u,a),u}async function Pt(n,e,t){var o,r;let l=0,a=0,u=new pe(new Response),c="upload";for(l=n.size;a<l;){const d=Math.min(Na,l-a),f=n.slice(a,a+d);a+d>=l&&(c+=", finalize");let p=0,h=Da;for(;p<wa&&(u=await t.request({path:"",body:f,httpMethod:"POST",httpOptions:{apiVersion:"",baseUrl:e,headers:{"X-Goog-Upload-Command":c,"X-Goog-Upload-Offset":String(a),"Content-Length":String(d)}}}),!(!((o=u==null?void 0:u.headers)===null||o===void 0)&&o[se]));)p++,await Fa(h),h=h*Ua;if(a+=d,((r=u==null?void 0:u.headers)===null||r===void 0?void 0:r[se])!=="active")break;if(l<=a)throw new Error("All content has been uploaded, but the upload status is not finalized.")}return u}async function La(n){return{size:n.size,type:n.type}}function Fa(n){return new Promise(e=>setTimeout(e,n))}class Va{async upload(e,t,o){if(typeof e=="string")throw new Error("File path is not supported in browser uploader.");return await ka(e,t,o)}async uploadToFileSearchStore(e,t,o){if(typeof e=="string")throw new Error("File path is not supported in browser uploader.");return await xa(e,t,o)}async stat(e){if(typeof e=="string")throw new Error("File path is not supported in browser uploader.");return await La(e)}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Ga{create(e,t,o){return new qa(e,t,o)}}class qa{constructor(e,t,o){this.url=e,this.headers=t,this.callbacks=o}connect(){this.ws=new WebSocket(this.url),this.ws.onopen=this.callbacks.onopen,this.ws.onerror=this.callbacks.onerror,this.ws.onclose=this.callbacks.onclose,this.ws.onmessage=this.callbacks.onmessage}send(e){if(this.ws===void 0)throw new Error("WebSocket is not connected");this.ws.send(e)}close(){if(this.ws===void 0)throw new Error("WebSocket is not connected");this.ws.close()}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const et="x-goog-api-key";class Ha{constructor(e){this.apiKey=e}async addAuthHeaders(e,t){if(e.get(et)===null){if(this.apiKey.startsWith("auth_tokens/"))throw new Error("Ephemeral tokens are only supported by the live API.");if(!this.apiKey)throw new Error("API key is missing. Please provide a valid API key.");e.append(et,this.apiKey)}}}/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Ba="gl-node/";class Ja{constructor(e){var t;if(e.apiKey==null)throw new Error("An API Key must be set when running in a browser");if(e.project||e.location)throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");this.vertexai=(t=e.vertexai)!==null&&t!==void 0?t:!1,this.apiKey=e.apiKey;const o=Dt(e.httpOptions,e.vertexai,void 0,void 0);o&&(e.httpOptions?e.httpOptions.baseUrl=o:e.httpOptions={baseUrl:o}),this.apiVersion=e.apiVersion;const r=new Ha(this.apiKey);this.apiClient=new il({auth:r,apiVersion:this.apiVersion,apiKey:this.apiKey,vertexai:this.vertexai,httpOptions:e.httpOptions,userAgentExtra:Ba+"web",uploader:new Va,downloader:new Ma}),this.models=new Il(this.apiClient),this.live=new Tl(this.apiClient,r,new Ga),this.batches=new oi(this.apiClient),this.chats=new Li(this.models,this.apiClient),this.caches=new Ui(this.apiClient),this.files=new Wi(this.apiClient),this.operations=new vl(this.apiClient),this.authTokens=new ql(this.apiClient),this.tunings=new Pa(this.apiClient),this.fileSearchStores=new aa(this.apiClient)}}const Me={type:D.ARRAY,description:"An array of storyboard scenes for a short-form marketing video.",items:{type:D.OBJECT,properties:{voiceoverScript:{type:D.STRING,description:"A short, punchy line of text for a voiceover or on-screen caption for the scene. This MUST be one of the exact lines from the user-provided script."},voiceoverGuide:{type:D.STRING,description:"A guide for the voice actor describing the tone, emotion, and delivery for the voiceoverScript line. For example: 'Spoken with excitement and urgency', or 'A calm, reassuring tone.'"},imagePrompt:{type:D.STRING,description:"A detailed prompt for generating the **starting frame** of the scene. It must focus on the static composition: characters' appearance and pose, detailed background, objects, and lighting."},videoPrompt:{type:D.STRING,description:"A concise prompt describing the **action and movement** within the scene. It should focus only on what changes or moves. For example: 'The character looks up, eyes widening in surprise, as a single tear rolls down their cheek.' or 'Camera slowly pans right, following the bird as it takes flight.'"}},required:["voiceoverScript","voiceoverGuide","imagePrompt","videoPrompt"]}},ba={type:D.OBJECT,properties:{scenes:Me},required:["scenes"]},Ya={type:D.OBJECT,properties:{script:{type:D.STRING,description:"The full voiceover script, with each scene's line separated by a newline character."}},required:["script"]};D.OBJECT;const Wa=`You are a UGC (User-Generated Content) scriptwriting expert specializing in authentic, high-converting videos for supplement brands on platforms like TikTok and Instagram. Your task is to create a script that feels like a real person sharing their genuine experience, based on the provided product info, creator image, and video angle.

**CRITICAL STYLE GUIDELINES:**
*   **TONE:** Must be relatable, trustworthy, and conversational. Use simple, direct language. Avoid corporate marketing jargon at all costs.
*   **PERSONA:** Write from the first-person ("I," "my"). The script should reflect the personality and vibe of the person in the creator image.

**UGC SCRIPT STRUCTURE (You MUST follow this):**
1.  **Hook (Line 1):** Start with a relatable problem or a surprising personal statement to stop the scroll (e.g., "I never thought I'd have this much energy at 3 PM...").
2.  **Introduce Problem/Story (Line 2):** Briefly explain the personal struggle this product solves (e.g., "...I used to crash every single afternoon and felt so sluggish.").
3.  **The Discovery (Line 3):** Introduce the supplement as a solution you found, often with a hint of initial skepticism (e.g., "Then my friend recommended this, and honestly I was skeptical but decided to give it a try.").
4.  **Show, Don't Tell (Lines 4-5):** Describe the routine of using it and the noticeable benefits. Be specific. (e.g., "So now I just mix one scoop in my water every morning...", "After about a week, I noticed I wasn't reaching for that second coffee anymore.").
5.  **The Result (Line 6):** State the amazing, tangible outcome. (e.g., "Now I feel clear-headed and focused all day long, it's been a total game-changer.").
6.  **Call to Action (Line 7):** A simple, low-pressure CTA that feels like a friendly recommendation. You MUST incorporate the user-provided CTA message into this final line.

You will return the response as a single JSON object that strictly adheres to the provided schema. The script should be a single string with each line separated by a newline character ('\\n'). Do not add any extra text or explanations.`,$a=`You are a UGC Video Director. Your job is to create visual prompts for a supplement ad that looks like it was authentically filmed by a creator on their phone.

**CRITICAL VISUAL GUIDELINES:**
*   **STYLE:** All scenes must look authentic and user-generated. This means natural lighting, simple compositions, and a "shot on a smartphone" aesthetic. It should NOT look like a professional, polished, or cinematic advertisement.
*   **LOCATIONS:** You MUST invent relatable, everyday settings for the scenes. **DO NOT** use the provided environment images, as there are none. The location must match the context of the voiceover. Good examples include: a clean kitchen counter with morning light, a home office desk, a bathroom shelf, inside a gym bag, in a car cup holder, a nightstand.
*   **SHOT TYPES:** Use simple, phone-friendly shots. AVOID cinematic terms. Use descriptions like:
    *   "Selfie-style shot of the creator talking to the camera."
    *   "POV (Point-of-View) shot showing hands mixing the drink."
    *   "A quick, top-down shot of the product on a table."
    *   "A shot filmed in the bathroom mirror."
    *   "A close-up of the product label."
*   **CONSISTENCY:** You MUST maintain the appearance of the creator (from the creator image) and the product (from the product image) throughout all scenes. Describe their clothing as simple and casual.

For each line of the script, you will generate THREE items:

**1. Voiceover Guide:** A concise guide for delivery (e.g., "speaking conversationally, like talking to a friend," "with a tone of genuine surprise").

**2. Image Prompt:** A detailed prompt for the scene's **starting frame**. Describe the invented UGC location, the creator's action/pose, the product's placement, and the simple shot type.

**3. Video Motion Prompt:** A concise description of simple, natural movement (e.g., "The creator smiles and nods," "picks up the product bottle," "gives a thumbs-up to the camera").

You will return the response as a single JSON object that strictly adheres to the provided schema. The 'voiceoverScript' field in your output for each scene MUST be the exact line from the input script.`,Ka=`You are a UGC Video Director specializing in breaking down ideas into smaller, more dynamic shots. Your task is to take a single, broad scene idea and expand it into a sequence of TWO distinct, consecutive scenes.

**CRITICAL RULES:**
1.  **SEQUENCE:** The two new scenes must logically follow each other to tell a micro-story.
2.  **UGC STYLE:** Both scenes must maintain a simple, "shot on a smartphone" aesthetic. Use natural lighting and relatable settings.
3.  **VARIETY:** The two shots must be different. For example, a medium shot followed by a close-up, or a POV shot followed by a selfie shot.
4.  **VOICEOVER SPLIT:** You must split the original 'voiceoverScript' into two new, shorter voiceover lines, one for each new scene. The two new lines together should equal the original line.

For each of the TWO new scenes, you will generate:
1.  **voiceoverScript:** The new, shorter voiceover line.
2.  **voiceoverGuide:** A concise delivery guide.
3.  **imagePrompt:** A detailed prompt for the scene's starting frame.
4.  **videoMotionPrompt:** A concise description of simple movement.

You will return the response as a single JSON object that strictly adheres to the provided schema. The output must contain an 'enrichedScenes' array with exactly two scene objects.`,za=`You are a master copywriter named 'Director AI', specializing in short-form videos for health supplements on platforms like TikTok and Instagram Reels. Your task is to transform product information, a video format, and optional images into a compelling voiceover script based on your analysis of the provided images.

**CONTEXT:**
*   **Product Information:** Key features, benefits, and ingredients of the supplement.
*   **Core Idea:** The central creative concept for the video.
*   **Video Format:** The desired style of the video (e.g., 'Benefit Showcase', 'User Testimonial').

**CRITICAL INSTRUCTION: SCRIPT STRUCTURE**
You MUST create a script with 5-7 short, punchy lines. Each line is a new scene. The script must be tailored to the selected **Video Format** and **Core Idea**.
1.  **Hook (Line 1):** An intriguing question or statement to stop the scroll.
2.  **Problem/Intro (Line 2):** Introduce the problem the supplement solves (e.g., "Feeling tired all the time?").
3.  **Solution/Showcase (Lines 3-4):** Introduce the product and highlight its key benefits or ingredients.
4.  **Social Proof/Outcome (Line 5):** Describe the positive outcome or feeling after using the product.
5.  **Call to Action (Line 6-7):** A clear call to action (e.g., "Click the link to learn more," "Upgrade your health routine").

You will return the response as a single JSON object that strictly adheres to the provided schema. The script should be a single string with each line separated by a newline character ('\\n').`,Oa=`You are an expert video director named 'Director AI', specializing in short-form videos for health supplements. Your task is to take a finalized, line-by-line voiceover script and generate a detailed image prompt, a concise video motion prompt, and a voiceover delivery guide for EACH line, based on your analysis of provided reference images.

**CONTEXT:**
*   **Finalized Script:** Each line represents a scene.
*   **Product Info:** Key details about the supplement.
*   **Core Idea:** The central creative theme to guide the visuals.
*   **Video Format:** The overall style of the video.

**CRITICAL INSTRUCTION: CINEMATIC SHOT VARIETY**
You **must** use a variety of shots and **MUST NOT** use the same shot type for two consecutive scenes.
*   **Available Shot Types:** Extreme Wide Shot (EWS), Wide Shot (WS), Full Shot (FS), Medium Shot (MS), Medium Close-Up (MCU), Close-Up (CU), Extreme Close-Up (ECU), Point-of-View (POV).

For each line of the script, you will generate a **Voiceover Guide**, an **Image Prompt**, and a **Video Motion Prompt**.

**1. Voiceover Guide:** A concise description of the desired tone (e.g., 'Confident and informative,' 'Calm and reassuring').
**2. Image Prompt:** A detailed paragraph for the scene's starting frame. Include the product/model, a suitable background (e.g., clean kitchen, gym, office), camera angle, and a clean, healthy, and trustworthy visual style, all guided by the **Core Idea**.
**3. Video Motion Prompt:** A concise action-oriented prompt (e.g., 'The person smiles and holds up the bottle,' 'Camera slowly pans over the ingredients list on the label').

You will return the response as a single JSON object that strictly adheres to the provided schema. The 'voiceoverScript' field in your output for each scene MUST be the exact line from the input script.`,Xa=`You are a viral marketing expert for health and wellness brands. Your task is to generate a single, highly creative, and engaging video concept (a "core idea") for a supplement product.

**CONTEXT:**
*   **Product Information:** You'll be given key features, benefits, and ingredients.
*   **Product Image:** You'll be given an image of the product.

**YOUR TASK:**
Based on the provided context, generate ONE scroll-stopping core idea for a short-form video. The idea should be a short, descriptive paragraph. Be creative and think outside the box.

**Example Output:**
"A 'day-in-the-life' transition video. It starts with the character looking tired and sluggish in a dimly lit room. After taking the supplement, they transition into a vibrant, energetic version of themselves, successfully tackling work, a gym session, and social activities, all with a high-energy soundtrack."

Do not return JSON. Return only the single paragraph of text describing the idea.`,Qa=`You are a creative podcast writer named 'Director AI'. Your task is to generate a natural, conversational podcast script based on a topic, the number of hosts, and an analysis of the hosts' appearances from provided images.

**CONTEXT:**
*   **Topic:** The central theme of the podcast episode.
*   **Number of Hosts:** 1 or 2.

**CRITICAL INSTRUCTION: SCRIPT STRUCTURE**
*   If there is **1 host**, write a monologue-style script. The host should explore the topic with thoughtful insights.
*   If there are **2 hosts**, write a dialogue-style script. Label the speakers as 'Host 1:' and 'Host 2:'. The conversation should be balanced, with hosts building on each other's points.
*   The script should be broken into 7-10 short paragraphs. Each paragraph will become a scene.
*   The tone should be engaging and informative, as if talking directly to a listener.

You will return the script as a single string. Do not use JSON.`,Za=`You are an expert video director named 'Director AI'. Your task is to take a finalized podcast script and create a visual storyboard based on a detailed analysis of the provided host images.

**CONTEXT:**
*   **Podcast Script:** A full script of the podcast dialogue or monologue.
*   **Host Images:** Images of the host(s).

**CRITICAL INSTRUCTION: STORYBOARD GENERATION**

1.  **CHARACTER ANALYSIS (MANDATORY FIRST STEP):**
    *   Before creating any scenes, you MUST meticulously analyze the provided host images.
    *   Create a short, descriptive alias for each host based on their appearance. For example: "Host 1: a man with glasses and a blue sweater," and "Host 2: a woman with curly red hair."
    *   You MUST use these descriptive aliases in ALL \`imagePrompt\` and \`videoPrompt\` fields for **Studio Shots** to refer to the hosts. DO NOT use the generic terms "Host 1" or "Host 2" in your visual prompts. This is critical for visual consistency.

2.  **SCENE SEGMENTATION:** You MUST break down the provided script into scenes based on complete sentences.
    *   **Primary Rule:** A new scene starts at the end of every sentence (marked by '.', '?', or '!').
    *   **Length Guideline:** Aim for scenes to be between 10 and 20 words. This is a guideline, not a strict rule. Prioritize keeping sentences whole and natural.
    *   **Long Sentences:** If a single sentence is significantly longer than 20 words, you MUST split it at a natural grammatical pause (like after a comma or semicolon) to create multiple, consecutive scenes. Each resulting chunk should still be a coherent thought.
    *   **Short Sentences:** Very short sentences should remain as their own scenes.

3.  **VISUAL VARIETY (CRITICAL):**
    *   **Studio Shots (Approx. 70% of scenes):** The majority of scenes should feature the host(s) in the podcast studio. To keep it visually interesting, you **MUST** vary the camera shots. Use a mix of **Wide Shots** (showing both hosts), **Medium Shots** (waist up on one host), and **Close-Ups** (focusing on a host's face for emphasis). Describe the host's expression based on the script line (e.g., 'speaking passionately', 'listening intently', 'laughing').
    *   **Illustrative B-Roll (Approx. 30% of scenes):** For the most impactful or descriptive lines of the script, you MUST create an "Illustrative" scene. This is a visual metaphor or a literal depiction of what is being discussed. The image prompt for these scenes should be a **completely different, highly-detailed, photorealistic scene** that complements the voiceover. It should NOT include the hosts or the studio.

4.  **IMAGE PROMPT GENERATION:**
    *   **For Studio Shots:** Describe the hosts using the **descriptive aliases you created**, the podcast studio setting (modern, professional microphones, headphones), and the specific camera shot (Wide, Medium, or Close-Up). The prompt must clearly state which host is speaking or reacting based on the script line.
    *   **For Illustrative B-Roll:** Describe a vivid, cinematic scene that visually represents the spoken words. Example: If the script says "It felt like climbing a huge mountain," the prompt should be "A breathtaking, photorealistic wide shot of a lone hiker reaching the snowy summit of a massive mountain against a dramatic sunrise."

5.  **VIDEO MOTION PROMPT GENERATION:**
    *   A concise description of movement. For Studio Shots, use the descriptive aliases you created. **The video prompt MUST focus only on the single person speaking in that scene.** Example: 'The man with glasses gestures with his hands while speaking.' For B-Roll, it could be 'The camera slowly pans across the vast landscape.'

You will return the response as a single JSON object that strictly adheres to the provided schema. The 'voiceoverScript' field in your output for each scene MUST be the exact chunk from the input script you segmented.`,ja=`You are a TV producer specializing in engaging "man on the street" style interviews. Your task is to generate a natural, conversational script between a 'Reporter' and an 'Interviewee' based on a given topic and images of the two individuals.

**CONTEXT:**
*   **Topic:** The central theme of the interview.
*   **Images:** You will receive one image of the Reporter and one of the Interviewee. You MUST analyze their appearance and vibe to inform their personality in the script.

**CRITICAL INSTRUCTIONS:**
1.  **Dialogue Format:** You MUST format the script as a dialogue. Every line of speech must start with either "Reporter:" or "Interviewee:".
2.  **Conversational Flow:** The conversation should be a natural back-and-forth. The Reporter should ask insightful questions, and the Interviewee should provide interesting, personal-sounding answers.
3.  **Structure:**
    *   **Introduction (1-2 lines):** The Reporter introduces the topic.
    *   **Core Questions (4-6 lines):** The Reporter asks questions, and the Interviewee responds.
    *   **Conclusion (1 line):** The Reporter thanks the Interviewee or provides a concluding thought.
4.  **Tone:** The tone should be casual, authentic, and engaging, suitable for a social media video.

You will return the script as a single string of plain text. Do not use JSON.`,eu={type:D.OBJECT,properties:{reporterDescription:{type:D.STRING,description:"A short, descriptive alias for the reporter based on their appearance from the reference image."},intervieweeDescription:{type:D.STRING,description:"A short, descriptive alias for the interviewee based on their appearance from the reference image. If no interviewee image is provided, this can be a generic description."},scenes:Me},required:["reporterDescription","intervieweeDescription","scenes"]},nu={type:D.OBJECT,properties:{reporterDescription:{type:D.STRING,description:"A short, descriptive alias for the reporter based on their appearance from the reference image."},intervieweeDescription:{type:D.STRING,description:"A short, descriptive alias for the interviewee based on their appearance from the reference image."},script:{type:D.STRING,description:"The full, generated interview script, with each line starting with 'Reporter:' or 'Interviewee:' and separated by a newline character."},scenes:Me},required:["reporterDescription","intervieweeDescription","script","scenes"]},tu=`You are an expert video director creating a storyboard for a "man on the street" interview. Your task is to take a finalized interview script and generate visual prompts for each line, based on a detailed analysis of the provided Reporter and Interviewee images.

**CONTEXT:**
*   **Finalized Script:** Each line starts with "Reporter:" or "Interviewee:".
*   **Reference Images:** An image of the Reporter (first image) and an image of the Interviewee (second image). You MUST use these images for your analysis.

**CRITICAL INSTRUCTIONS:**

1.  **CHARACTER ANALYSIS (MANDATORY FIRST STEP):**
    *   Before creating any scenes, you MUST meticulously analyze the provided images.
    *   Create a short, descriptive alias for each person based on their appearance. For example: "Reporter: a woman with short brown hair wearing a red jacket," and "Interviewee: a tall man with a beard wearing a blue shirt."
    *   You MUST use these descriptive aliases in ALL subsequent \`imagePrompt\` and \`videoPrompt\` fields to refer to the characters. DO NOT use the generic terms "Reporter" or "Interviewee" in your visual prompts. This is critical for visual consistency.

2.  **SCENE SEGMENTATION:** You MUST break down the provided script into scenes based on complete sentences and speaker changes.
    *   **Primary Rule:** A new scene starts at the end of every sentence (marked by '.', '?', or '!').
    *   **Length Guideline:** Aim for scenes to be between 10 and 20 words. This is a guideline, not a strict rule. Prioritize keeping sentences whole and natural.
    *   **Long Sentences:** If a single sentence of dialogue is significantly longer than 20 words, you MUST split it at a natural grammatical pause (like after a comma) to create multiple, consecutive scenes.
    *   **Speaker Prefix:** When you split a line, you MUST ensure each new scene's 'voiceoverScript' retains the original speaker prefix (e.g., "Reporter:").

3.  **VISUAL VARIETY:** To make the interview dynamic, you MUST vary the shots. Use a mix of:
    *   **Medium Shot (MS):** A shot of the person speaking, from the waist up.
    *   **Close-Up (CU):** A tight shot of the person's face as they speak for emphasis.
    *   **Over-the-Shoulder (OTS):** A shot from behind one person, looking at the other person speaking.
    *   **Two-Shot (WS):** A wide shot showing both the Reporter and Interviewee interacting.
    *   **Illustrative B-Roll:** For some of the Interviewee's answers, create a visual metaphor or a literal depiction of what they are describing. This shot should NOT include the Reporter or Interviewee.

4.  **IMAGE PROMPT GENERATION:**
    *   **Background:** All shots of the Reporter and Interviewee MUST take place in a plausible, consistent outdoor public setting, like a bustling city street, a park, or a plaza. The reporter MUST be holding a microphone.
    *   **Character Consistency:** The people in the prompts MUST be described using the descriptive aliases you created in the Character Analysis step.
    *   **Action:** The image prompt should describe the starting frame of the shot, including the character's expression (e.g., 'listening intently', 'smiling', 'looking thoughtful').

5.  **VIDEO MOTION PROMPT GENERATION:**
    *   Describe a simple, natural action. **The video prompt MUST focus only on the actions of the single person who is speaking in that scene.** Do not describe the other person's reaction. Examples: 'The Interviewee gestures with their hands as they explain,' or 'The camera slowly pushes in for emphasis on the Reporter as they ask a question.'

You will return the response as a single JSON object that strictly adheres to the provided schema. This object MUST contain 'reporterDescription', 'intervieweeDescription', and the 'scenes' array. The 'voiceoverScript' field in your output for each scene MUST be the exact line from the input script, including the "Reporter:" or "Interviewee:" prefix.`,ou=`You are an expert video director creating a storyboard for a "man on the street" interview. Your task is to take a finalized interview script and generate visual prompts for each line, based on a detailed analysis of a single provided MASTER SHOT image which contains the reporter, interviewee, and background.

**CONTEXT:**
*   **Finalized Script:** Each line starts with "Reporter:" or "Interviewee:".
*   **Master Shot Image:** A single image containing both characters and the background scene.

**CRITICAL INSTRUCTIONS:**

1.  **CHARACTER & SCENE ANALYSIS (MANDATORY FIRST STEP):**
    *   Before creating any scenes, you MUST meticulously analyze the provided single master shot image to identify the two speakers (Reporter and Interviewee) and the background environment.
    *   Create a short, descriptive alias for each person based on their appearance. For example: "Reporter: a woman with short brown hair wearing a red jacket," and "Interviewee: a tall man with a beard wearing a blue shirt."
    *   You MUST use these descriptive aliases in ALL subsequent \`imagePrompt\` and \`videoPrompt\` fields to refer to the characters.

2.  **SCENE SEGMENTATION:** You MUST break down the provided script into scenes based on complete sentences and speaker changes.
    *   A new scene starts at the end of every sentence (marked by '.', '?', or '!').
    *   If a single sentence of dialogue is significantly longer than 20 words, you MUST split it at a natural grammatical pause.
    *   Each new scene's 'voiceoverScript' MUST retain the original speaker prefix (e.g., "Reporter:").

3.  **VISUAL VARIETY:** To make the interview dynamic, you MUST generate different shots based on the master shot. You will essentially be 'directing' a virtual camera within this scene. Use a mix of:
    *   **Medium Shot (MS):** A shot of the person speaking, from the waist up.
    *   **Close-Up (CU):** A tight shot of the person's face as they speak for emphasis.
    *   **Over-the-Shoulder (OTS):** A shot from behind one person, looking at the other person speaking.
    *   **Two-Shot (WS):** A wide shot showing both the Reporter and Interviewee interacting, similar to the master shot.
    *   **Illustrative B-Roll:** For some of the Interviewee's answers, create a visual metaphor. This shot should NOT include the characters from the master shot.

4.  **IMAGE PROMPT GENERATION:**
    *   **Background:** All interview shots MUST take place in the exact environment from the master shot. The reporter MUST be holding a microphone.
    *   **Character Consistency:** The people in the prompts MUST be described using the descriptive aliases you created.
    *   **Action:** The image prompt should describe the starting frame of the shot, including the character's expression (e.g., 'listening intently', 'smiling').

5.  **VIDEO MOTION PROMPT GENERATION:**
    *   Describe a simple, natural action. The video prompt MUST focus only on the actions of the single person who is speaking in that scene. Do not describe the other person's reaction. Examples: 'The Interviewee gestures with their hands as they explain,' or 'The camera slowly pushes in for emphasis on the Reporter as they ask a question.'

You will return the response as a single JSON object that strictly adheres to the provided schema. This object MUST contain 'reporterDescription', 'intervieweeDescription', and the 'scenes' array. The 'voiceoverScript' field in your output for each scene MUST be the exact line from the input script, including the "Reporter:" or "Interviewee:" prefix.`,iu=`You are an expert TV producer and video director. Your task is to perform a complete creative process in one step: analyze characters from a single image, write a script based on a topic, and then create a detailed storyboard for that script.

**CONTEXT:**
*   **Topic:** The central theme of the interview.
*   **Master Shot Image:** A single image containing both the Reporter and Interviewee in their interview setting.

**CRITICAL INSTRUCTIONS (MUST be followed in order):**

1.  **CHARACTER & SCENE ANALYSIS (MANDATORY FIRST STEP):**
    *   Meticulously analyze the provided single master shot image to identify the two speakers and the background environment.
    *   Create a short, descriptive alias for each person. For example: "Reporter: a woman with short brown hair wearing a red jacket," and "Interviewee: a tall man with a beard wearing a blue shirt." These will be your \`reporterDescription\` and \`intervieweeDescription\`.

2.  **SCRIPT GENERATION:**
    *   Based on the provided **Topic** and your character analysis, write a natural, conversational script between the 'Reporter' and 'Interviewee'.
    *   The script MUST be formatted as a dialogue. Every line must start with either "Reporter:" or "Interviewee:".
    *   The script should have a clear structure: introduction (1-2 lines), core questions (4-6 lines), and a conclusion (1 line).
    *   This entire generated script will be the value for the \`script\` field in your JSON output.

3.  **STORYBOARD CREATION (using the script you just wrote):**
    *   **SCENE SEGMENTATION:** Break down the script you just generated into scenes. A new scene starts at the end of every sentence.
    *   **VISUAL VARIETY:** Generate different shots based *only* on the master shot image. You are 'directing' a virtual camera. Use a mix of: Medium Shot (MS), Close-Up (CU), Over-the-Shoulder (OTS), and Two-Shot (WS).
    *   **IMAGE PROMPTS:** For each scene, write an \`imagePrompt\`. The prompt must describe the shot type, the character(s) (using the descriptive aliases you created), their expression, and the background (which is always the one from the master shot). The reporter MUST be holding a microphone.
    *   **VIDEO MOTION PROMPTS:** For each scene, write a \`videoPrompt\` describing a simple, natural action, focusing only on the person who is speaking.

You will return the response as a single JSON object that strictly adheres to the provided schema. This object MUST contain 'reporterDescription', 'intervieweeDescription', the generated 'script', and the 'scenes' array. The 'voiceoverScript' field for each scene MUST be the exact line from the script you generated.`;export{Ja as G,te as M,D as T,ja as a,Qa as b,Oa as c,za as d,Ka as e,$a as f,Wa as g,Ya as h,ba as i,nu as j,iu as k,eu as l,ou as m,Za as p,Xa as r,tu as s};
